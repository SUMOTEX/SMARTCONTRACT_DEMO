"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/oauth4webapi";
exports.ids = ["vendor-chunks/oauth4webapi"];
exports.modules = {

/***/ "(rsc)/./node_modules/oauth4webapi/build/index.js":
/*!**************************************************!*\
  !*** ./node_modules/oauth4webapi/build/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OperationProcessingError: () => (/* binding */ OperationProcessingError),\n/* harmony export */   UnsupportedOperationError: () => (/* binding */ UnsupportedOperationError),\n/* harmony export */   authorizationCodeGrantRequest: () => (/* binding */ authorizationCodeGrantRequest),\n/* harmony export */   calculatePKCECodeChallenge: () => (/* binding */ calculatePKCECodeChallenge),\n/* harmony export */   clientCredentialsGrantRequest: () => (/* binding */ clientCredentialsGrantRequest),\n/* harmony export */   clockSkew: () => (/* binding */ clockSkew),\n/* harmony export */   clockTolerance: () => (/* binding */ clockTolerance),\n/* harmony export */   deviceAuthorizationRequest: () => (/* binding */ deviceAuthorizationRequest),\n/* harmony export */   deviceCodeGrantRequest: () => (/* binding */ deviceCodeGrantRequest),\n/* harmony export */   discoveryRequest: () => (/* binding */ discoveryRequest),\n/* harmony export */   expectNoNonce: () => (/* binding */ expectNoNonce),\n/* harmony export */   expectNoState: () => (/* binding */ expectNoState),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   generateRandomCodeVerifier: () => (/* binding */ generateRandomCodeVerifier),\n/* harmony export */   generateRandomNonce: () => (/* binding */ generateRandomNonce),\n/* harmony export */   generateRandomState: () => (/* binding */ generateRandomState),\n/* harmony export */   getValidatedIdTokenClaims: () => (/* binding */ getValidatedIdTokenClaims),\n/* harmony export */   introspectionRequest: () => (/* binding */ introspectionRequest),\n/* harmony export */   isOAuth2Error: () => (/* binding */ isOAuth2Error),\n/* harmony export */   issueRequestObject: () => (/* binding */ issueRequestObject),\n/* harmony export */   parseWwwAuthenticateChallenges: () => (/* binding */ parseWwwAuthenticateChallenges),\n/* harmony export */   processAuthorizationCodeOAuth2Response: () => (/* binding */ processAuthorizationCodeOAuth2Response),\n/* harmony export */   processAuthorizationCodeOpenIDResponse: () => (/* binding */ processAuthorizationCodeOpenIDResponse),\n/* harmony export */   processClientCredentialsResponse: () => (/* binding */ processClientCredentialsResponse),\n/* harmony export */   processDeviceAuthorizationResponse: () => (/* binding */ processDeviceAuthorizationResponse),\n/* harmony export */   processDeviceCodeResponse: () => (/* binding */ processDeviceCodeResponse),\n/* harmony export */   processDiscoveryResponse: () => (/* binding */ processDiscoveryResponse),\n/* harmony export */   processIntrospectionResponse: () => (/* binding */ processIntrospectionResponse),\n/* harmony export */   processPushedAuthorizationResponse: () => (/* binding */ processPushedAuthorizationResponse),\n/* harmony export */   processRefreshTokenResponse: () => (/* binding */ processRefreshTokenResponse),\n/* harmony export */   processRevocationResponse: () => (/* binding */ processRevocationResponse),\n/* harmony export */   processUserInfoResponse: () => (/* binding */ processUserInfoResponse),\n/* harmony export */   protectedResourceRequest: () => (/* binding */ protectedResourceRequest),\n/* harmony export */   pushedAuthorizationRequest: () => (/* binding */ pushedAuthorizationRequest),\n/* harmony export */   refreshTokenGrantRequest: () => (/* binding */ refreshTokenGrantRequest),\n/* harmony export */   revocationRequest: () => (/* binding */ revocationRequest),\n/* harmony export */   skipAuthTimeCheck: () => (/* binding */ skipAuthTimeCheck),\n/* harmony export */   skipStateCheck: () => (/* binding */ skipStateCheck),\n/* harmony export */   skipSubjectCheck: () => (/* binding */ skipSubjectCheck),\n/* harmony export */   userInfoRequest: () => (/* binding */ userInfoRequest),\n/* harmony export */   validateAuthResponse: () => (/* binding */ validateAuthResponse),\n/* harmony export */   validateJwtAuthResponse: () => (/* binding */ validateJwtAuthResponse)\n/* harmony export */ });\nlet USER_AGENT;\nif (typeof navigator === \"undefined\" || !navigator.userAgent?.startsWith?.(\"Mozilla/5.0 \")) {\n    const NAME = \"oauth4webapi\";\n    const VERSION = \"v2.4.0\";\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nconst clockSkew = Symbol();\nconst clockTolerance = Symbol();\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nfunction buf(input) {\n    if (typeof input === \"string\") {\n        return encoder.encode(input);\n    }\n    return decoder.decode(input);\n}\nconst CHUNK_SIZE = 0x8000;\nfunction encodeBase64Url(input) {\n    if (input instanceof ArrayBuffer) {\n        input = new Uint8Array(input);\n    }\n    const arr = [];\n    for(let i = 0; i < input.byteLength; i += CHUNK_SIZE){\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(\"\")).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction decodeBase64Url(input) {\n    try {\n        const binary = atob(input.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\"));\n        const bytes = new Uint8Array(binary.length);\n        for(let i = 0; i < binary.length; i++){\n            bytes[i] = binary.charCodeAt(i);\n        }\n        return bytes;\n    } catch (cause) {\n        throw new OPE(\"The input to be decoded is not correctly encoded.\", {\n            cause\n        });\n    }\n}\nfunction b64u(input) {\n    if (typeof input === \"string\") {\n        return decodeBase64Url(input);\n    }\n    return encodeBase64Url(input);\n}\nclass LRU {\n    constructor(maxSize){\n        this.cache = new Map();\n        this._cache = new Map();\n        this.maxSize = maxSize;\n    }\n    get(key) {\n        let v = this.cache.get(key);\n        if (v) {\n            return v;\n        }\n        if (v = this._cache.get(key)) {\n            this.update(key, v);\n            return v;\n        }\n        return undefined;\n    }\n    has(key) {\n        return this.cache.has(key) || this._cache.has(key);\n    }\n    set(key, value) {\n        if (this.cache.has(key)) {\n            this.cache.set(key, value);\n        } else {\n            this.update(key, value);\n        }\n        return this;\n    }\n    delete(key) {\n        if (this.cache.has(key)) {\n            return this.cache.delete(key);\n        }\n        if (this._cache.has(key)) {\n            return this._cache.delete(key);\n        }\n        return false;\n    }\n    update(key, value) {\n        this.cache.set(key, value);\n        if (this.cache.size >= this.maxSize) {\n            this._cache = this.cache;\n            this.cache = new Map();\n        }\n    }\n}\nclass UnsupportedOperationError extends Error {\n    constructor(message){\n        super(message ?? \"operation not supported\");\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nclass OperationProcessingError extends Error {\n    constructor(message, options){\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nconst OPE = OperationProcessingError;\nconst dpopNonces = new LRU(100);\nfunction isCryptoKey(key) {\n    return key instanceof CryptoKey;\n}\nfunction isPrivateKey(key) {\n    return isCryptoKey(key) && key.type === \"private\";\n}\nfunction isPublicKey(key) {\n    return isCryptoKey(key) && key.type === \"public\";\n}\nconst SUPPORTED_JWS_ALGS = [\n    \"PS256\",\n    \"ES256\",\n    \"RS256\",\n    \"PS384\",\n    \"ES384\",\n    \"RS384\",\n    \"PS512\",\n    \"ES512\",\n    \"RS512\",\n    \"EdDSA\"\n];\nfunction processDpopNonce(response) {\n    const url = new URL(response.url);\n    if (response.headers.has(\"dpop-nonce\")) {\n        dpopNonces.set(url.origin, response.headers.get(\"dpop-nonce\"));\n    }\n    return response;\n}\nfunction normalizeTyp(value) {\n    return value.toLowerCase().replace(/^application\\//, \"\");\n}\nfunction isJsonObject(input) {\n    if (input === null || typeof input !== \"object\" || Array.isArray(input)) {\n        return false;\n    }\n    return true;\n}\nfunction prepareHeaders(input) {\n    if (input !== undefined && !(input instanceof Headers)) {\n        throw new TypeError('\"options.headers\" must be an instance of Headers');\n    }\n    const headers = new Headers(input);\n    if (USER_AGENT && !headers.has(\"user-agent\")) {\n        headers.set(\"user-agent\", USER_AGENT);\n    }\n    if (headers.has(\"authorization\")) {\n        throw new TypeError('\"options.headers\" must not include the \"authorization\" header name');\n    }\n    if (headers.has(\"dpop\")) {\n        throw new TypeError('\"options.headers\" must not include the \"dpop\" header name');\n    }\n    return headers;\n}\nfunction signal(value) {\n    if (typeof value === \"function\") {\n        value = value();\n    }\n    if (!(value instanceof AbortSignal)) {\n        throw new TypeError('\"options.signal\" must return or be an instance of AbortSignal');\n    }\n    return value;\n}\nasync function discoveryRequest(issuerIdentifier, options) {\n    if (!(issuerIdentifier instanceof URL)) {\n        throw new TypeError('\"issuerIdentifier\" must be an instance of URL');\n    }\n    if (issuerIdentifier.protocol !== \"https:\" && issuerIdentifier.protocol !== \"http:\") {\n        throw new TypeError('\"issuer.protocol\" must be \"https:\" or \"http:\"');\n    }\n    const url = new URL(issuerIdentifier.href);\n    switch(options?.algorithm){\n        case undefined:\n        case \"oidc\":\n            url.pathname = `${url.pathname}/.well-known/openid-configuration`.replace(\"//\", \"/\");\n            break;\n        case \"oauth2\":\n            if (url.pathname === \"/\") {\n                url.pathname = `.well-known/oauth-authorization-server`;\n            } else {\n                url.pathname = `.well-known/oauth-authorization-server/${url.pathname}`.replace(\"//\", \"/\");\n            }\n            break;\n        default:\n            throw new TypeError('\"options.algorithm\" must be \"oidc\" (default), or \"oauth2\"');\n    }\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return fetch(url.href, {\n        headers,\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nfunction validateString(input) {\n    return typeof input === \"string\" && input.length !== 0;\n}\nasync function processDiscoveryResponse(expectedIssuerIdentifier, response) {\n    if (!(expectedIssuerIdentifier instanceof URL)) {\n        throw new TypeError('\"expectedIssuer\" must be an instance of URL');\n    }\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform Authorization Server Metadata response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.issuer)) {\n        throw new OPE('\"response\" body \"issuer\" property must be a non-empty string');\n    }\n    if (new URL(json.issuer).href !== expectedIssuerIdentifier.href) {\n        throw new OPE('\"response\" body \"issuer\" does not match \"expectedIssuer\"');\n    }\n    return json;\n}\nfunction randomBytes() {\n    return b64u(crypto.getRandomValues(new Uint8Array(32)));\n}\nfunction generateRandomCodeVerifier() {\n    return randomBytes();\n}\nfunction generateRandomState() {\n    return randomBytes();\n}\nfunction generateRandomNonce() {\n    return randomBytes();\n}\nasync function calculatePKCECodeChallenge(codeVerifier) {\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    return b64u(await crypto.subtle.digest(\"SHA-256\", buf(codeVerifier)));\n}\nfunction getKeyAndKid(input) {\n    if (input instanceof CryptoKey) {\n        return {\n            key: input\n        };\n    }\n    if (!(input?.key instanceof CryptoKey)) {\n        return {};\n    }\n    if (input.kid !== undefined && !validateString(input.kid)) {\n        throw new TypeError('\"kid\" must be a non-empty string');\n    }\n    return {\n        key: input.key,\n        kid: input.kid\n    };\n}\nfunction formUrlEncode(token) {\n    return encodeURIComponent(token).replace(/%20/g, \"+\");\n}\nfunction clientSecretBasic(clientId, clientSecret) {\n    const username = formUrlEncode(clientId);\n    const password = formUrlEncode(clientSecret);\n    const credentials = btoa(`${username}:${password}`);\n    return `Basic ${credentials}`;\n}\nfunction psAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"PS256\";\n        case \"SHA-384\":\n            return \"PS384\";\n        case \"SHA-512\":\n            return \"PS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\");\n    }\n}\nfunction rsAlg(key) {\n    switch(key.algorithm.hash.name){\n        case \"SHA-256\":\n            return \"RS256\";\n        case \"SHA-384\":\n            return \"RS384\";\n        case \"SHA-512\":\n            return \"RS512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported RsaHashedKeyAlgorithm hash name\");\n    }\n}\nfunction esAlg(key) {\n    switch(key.algorithm.namedCurve){\n        case \"P-256\":\n            return \"ES256\";\n        case \"P-384\":\n            return \"ES384\";\n        case \"P-521\":\n            return \"ES512\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported EcKeyAlgorithm namedCurve\");\n    }\n}\nfunction keyToJws(key) {\n    switch(key.algorithm.name){\n        case \"RSA-PSS\":\n            return psAlg(key);\n        case \"RSASSA-PKCS1-v1_5\":\n            return rsAlg(key);\n        case \"ECDSA\":\n            return esAlg(key);\n        case \"Ed25519\":\n        case \"Ed448\":\n            return \"EdDSA\";\n        default:\n            throw new UnsupportedOperationError(\"unsupported CryptoKey algorithm name\");\n    }\n}\nfunction getClockSkew(client) {\n    if (Number.isFinite(client[clockSkew])) {\n        return client[clockSkew];\n    }\n    return 0;\n}\nfunction getClockTolerance(client) {\n    const tolerance = client[clockTolerance];\n    if (Number.isFinite(tolerance) && Math.sign(tolerance) !== -1) {\n        return tolerance;\n    }\n    return 30;\n}\nfunction epochTime() {\n    return Math.floor(Date.now() / 1000);\n}\nfunction clientAssertion(as, client) {\n    const now = epochTime() + getClockSkew(client);\n    return {\n        jti: randomBytes(),\n        aud: [\n            as.issuer,\n            as.token_endpoint\n        ],\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id,\n        sub: client.client_id\n    };\n}\nasync function privateKeyJwt(as, client, key, kid) {\n    return jwt({\n        alg: keyToJws(key),\n        kid\n    }, clientAssertion(as, client), key);\n}\nfunction assertAs(as) {\n    if (typeof as !== \"object\" || as === null) {\n        throw new TypeError('\"as\" must be an object');\n    }\n    if (!validateString(as.issuer)) {\n        throw new TypeError('\"as.issuer\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClient(client) {\n    if (typeof client !== \"object\" || client === null) {\n        throw new TypeError('\"client\" must be an object');\n    }\n    if (!validateString(client.client_id)) {\n        throw new TypeError('\"client.client_id\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClientSecret(clientSecret) {\n    if (!validateString(clientSecret)) {\n        throw new TypeError('\"client.client_secret\" property must be a non-empty string');\n    }\n    return clientSecret;\n}\nfunction assertNoClientPrivateKey(clientAuthMethod, clientPrivateKey) {\n    if (clientPrivateKey !== undefined) {\n        throw new TypeError(`\"options.clientPrivateKey\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nfunction assertNoClientSecret(clientAuthMethod, clientSecret) {\n    if (clientSecret !== undefined) {\n        throw new TypeError(`\"client.client_secret\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nasync function clientAuthentication(as, client, body, headers, clientPrivateKey) {\n    body.delete(\"client_secret\");\n    body.delete(\"client_assertion_type\");\n    body.delete(\"client_assertion\");\n    switch(client.token_endpoint_auth_method){\n        case undefined:\n        case \"client_secret_basic\":\n            {\n                assertNoClientPrivateKey(\"client_secret_basic\", clientPrivateKey);\n                headers.set(\"authorization\", clientSecretBasic(client.client_id, assertClientSecret(client.client_secret)));\n                break;\n            }\n        case \"client_secret_post\":\n            {\n                assertNoClientPrivateKey(\"client_secret_post\", clientPrivateKey);\n                body.set(\"client_id\", client.client_id);\n                body.set(\"client_secret\", assertClientSecret(client.client_secret));\n                break;\n            }\n        case \"private_key_jwt\":\n            {\n                assertNoClientSecret(\"private_key_jwt\", client.client_secret);\n                if (clientPrivateKey === undefined) {\n                    throw new TypeError('\"options.clientPrivateKey\" must be provided when \"client.token_endpoint_auth_method\" is \"private_key_jwt\"');\n                }\n                const { key, kid } = getKeyAndKid(clientPrivateKey);\n                if (!isPrivateKey(key)) {\n                    throw new TypeError('\"options.clientPrivateKey.key\" must be a private CryptoKey');\n                }\n                body.set(\"client_id\", client.client_id);\n                body.set(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n                body.set(\"client_assertion\", await privateKeyJwt(as, client, key, kid));\n                break;\n            }\n        case \"none\":\n            {\n                assertNoClientSecret(\"none\", client.client_secret);\n                assertNoClientPrivateKey(\"none\", clientPrivateKey);\n                body.set(\"client_id\", client.client_id);\n                break;\n            }\n        default:\n            throw new UnsupportedOperationError(\"unsupported client token_endpoint_auth_method\");\n    }\n}\nasync function jwt(header, claimsSet, key) {\n    if (!key.usages.includes(\"sign\")) {\n        throw new TypeError('CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"');\n    }\n    const input = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(claimsSet)))}`;\n    const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));\n    return `${input}.${signature}`;\n}\nasync function issueRequestObject(as, client, parameters, privateKey) {\n    assertAs(as);\n    assertClient(client);\n    parameters = new URLSearchParams(parameters);\n    const { key, kid } = getKeyAndKid(privateKey);\n    if (!isPrivateKey(key)) {\n        throw new TypeError('\"privateKey.key\" must be a private CryptoKey');\n    }\n    parameters.set(\"client_id\", client.client_id);\n    const now = epochTime() + getClockSkew(client);\n    const claims = {\n        ...Object.fromEntries(parameters.entries()),\n        jti: randomBytes(),\n        aud: as.issuer,\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id\n    };\n    let resource;\n    if (parameters.has(\"resource\") && (resource = parameters.getAll(\"resource\")) && resource.length > 1) {\n        claims.resource = resource;\n    }\n    if (parameters.has(\"claims\")) {\n        const value = parameters.get(\"claims\");\n        if (value === \"[object Object]\") {\n            throw new OPE('\"claims\" parameter must be passed as a UTF-8 encoded JSON');\n        }\n        try {\n            claims.claims = JSON.parse(value);\n        } catch (cause) {\n            throw new OPE('failed to parse the \"claims\" parameter as JSON', {\n                cause\n            });\n        }\n        if (!isJsonObject(claims.claims)) {\n            throw new OPE('\"claims\" parameter must be a top level object');\n        }\n    }\n    return jwt({\n        alg: keyToJws(key),\n        typ: \"oauth-authz-req+jwt\",\n        kid\n    }, claims, key);\n}\nasync function dpopProofJwt(headers, options, url, htm, clockSkew, accessToken) {\n    const { privateKey, publicKey, nonce = dpopNonces.get(url.origin) } = options;\n    if (!isPrivateKey(privateKey)) {\n        throw new TypeError('\"DPoP.privateKey\" must be a private CryptoKey');\n    }\n    if (!isPublicKey(publicKey)) {\n        throw new TypeError('\"DPoP.publicKey\" must be a public CryptoKey');\n    }\n    if (nonce !== undefined && !validateString(nonce)) {\n        throw new TypeError('\"DPoP.nonce\" must be a non-empty string or undefined');\n    }\n    if (!publicKey.extractable) {\n        throw new TypeError('\"DPoP.publicKey.extractable\" must be true');\n    }\n    const now = epochTime() + clockSkew;\n    const proof = await jwt({\n        alg: keyToJws(privateKey),\n        typ: \"dpop+jwt\",\n        jwk: await publicJwk(publicKey)\n    }, {\n        iat: now,\n        jti: randomBytes(),\n        htm,\n        nonce,\n        htu: `${url.origin}${url.pathname}`,\n        ath: accessToken ? b64u(await crypto.subtle.digest(\"SHA-256\", buf(accessToken))) : undefined\n    }, privateKey);\n    headers.set(\"dpop\", proof);\n}\nlet jwkCache;\nasync function publicJwk(key) {\n    jwkCache || (jwkCache = new WeakMap());\n    if (jwkCache.has(key)) {\n        return jwkCache.get(key);\n    }\n    const { kty, e, n, x, y, crv } = await crypto.subtle.exportKey(\"jwk\", key);\n    const jwk = {\n        kty,\n        e,\n        n,\n        x,\n        y,\n        crv\n    };\n    jwkCache.set(key, jwk);\n    return jwk;\n}\nasync function pushedAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    if (typeof as.pushed_authorization_request_endpoint !== \"string\") {\n        throw new TypeError('\"as.pushed_authorization_request_endpoint\" must be a string');\n    }\n    const url = new URL(as.pushed_authorization_request_endpoint);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, \"POST\", getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nfunction isOAuth2Error(input) {\n    const value = input;\n    if (typeof value !== \"object\" || Array.isArray(value) || value === null) {\n        return false;\n    }\n    return value.error !== undefined;\n}\nfunction unquote(value) {\n    if (value.length >= 2 && value[0] === '\"' && value[value.length - 1] === '\"') {\n        return value.slice(1, -1);\n    }\n    return value;\n}\nconst SPLIT_REGEXP = /((?:,|, )?[0-9a-zA-Z!#$%&'*+-.^_`|~]+=)/;\nconst SCHEMES_REGEXP = /(?:^|, ?)([0-9a-zA-Z!#$%&'*+\\-.^_`|~]+)(?=$|[ ,])/g;\nfunction wwwAuth(scheme, params) {\n    const arr = params.split(SPLIT_REGEXP).slice(1);\n    if (!arr.length) {\n        return {\n            scheme: scheme.toLowerCase(),\n            parameters: {}\n        };\n    }\n    arr[arr.length - 1] = arr[arr.length - 1].replace(/,$/, \"\");\n    const parameters = {};\n    for(let i = 1; i < arr.length; i += 2){\n        const idx = i;\n        if (arr[idx][0] === '\"') {\n            while(arr[idx].slice(-1) !== '\"' && ++i < arr.length){\n                arr[idx] += arr[i];\n            }\n        }\n        const key = arr[idx - 1].replace(/^(?:, ?)|=$/g, \"\").toLowerCase();\n        parameters[key] = unquote(arr[idx]);\n    }\n    return {\n        scheme: scheme.toLowerCase(),\n        parameters\n    };\n}\nfunction parseWwwAuthenticateChallenges(response) {\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (!response.headers.has(\"www-authenticate\")) {\n        return undefined;\n    }\n    const header = response.headers.get(\"www-authenticate\");\n    const result = [];\n    for (const { 1: scheme, index } of header.matchAll(SCHEMES_REGEXP)){\n        result.push([\n            scheme,\n            index\n        ]);\n    }\n    if (!result.length) {\n        return undefined;\n    }\n    const challenges = result.map(([scheme, indexOf], i, others)=>{\n        const next = others[i + 1];\n        let parameters;\n        if (next) {\n            parameters = header.slice(indexOf, next[1]);\n        } else {\n            parameters = header.slice(indexOf);\n        }\n        return wwwAuth(scheme, parameters);\n    });\n    return challenges;\n}\nasync function processPushedAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 201) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Pushed Authorization Request Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.request_uri)) {\n        throw new OPE('\"response\" body \"request_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== \"number\" || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    return json;\n}\nasync function protectedResourceRequest(accessToken, method, url, headers, body, options) {\n    if (!validateString(accessToken)) {\n        throw new TypeError('\"accessToken\" must be a non-empty string');\n    }\n    if (!(url instanceof URL)) {\n        throw new TypeError('\"url\" must be an instance of URL');\n    }\n    headers = prepareHeaders(headers);\n    if (options?.DPoP === undefined) {\n        headers.set(\"authorization\", `Bearer ${accessToken}`);\n    } else {\n        await dpopProofJwt(headers, options.DPoP, url, \"GET\", getClockSkew({\n            [clockSkew]: options?.clockSkew\n        }), accessToken);\n        headers.set(\"authorization\", `DPoP ${accessToken}`);\n    }\n    return fetch(url.href, {\n        body,\n        headers,\n        method,\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function userInfoRequest(as, client, accessToken, options) {\n    assertAs(as);\n    assertClient(client);\n    if (typeof as.userinfo_endpoint !== \"string\") {\n        throw new TypeError('\"as.userinfo_endpoint\" must be a string');\n    }\n    const url = new URL(as.userinfo_endpoint);\n    const headers = prepareHeaders(options?.headers);\n    if (client.userinfo_signed_response_alg) {\n        headers.set(\"accept\", \"application/jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n        headers.append(\"accept\", \"application/jwt\");\n    }\n    return protectedResourceRequest(accessToken, \"GET\", url, headers, null, {\n        ...options,\n        clockSkew: getClockSkew(client)\n    });\n}\nlet jwksCache;\nasync function getPublicSigKeyFromIssuerJwksUri(as, options, header) {\n    const { alg, kid } = header;\n    checkSupportedJwsAlg(alg);\n    let jwks;\n    let age;\n    jwksCache || (jwksCache = new WeakMap());\n    if (jwksCache.has(as)) {\n        ;\n        ({ jwks, age } = jwksCache.get(as));\n        if (age >= 300) {\n            jwksCache.delete(as);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n    } else {\n        jwks = await jwksRequest(as, options).then(processJwksResponse);\n        age = 0;\n        jwksCache.set(as, {\n            jwks,\n            iat: epochTime(),\n            get age () {\n                return epochTime() - this.iat;\n            }\n        });\n    }\n    let kty;\n    switch(alg.slice(0, 2)){\n        case \"RS\":\n        case \"PS\":\n            kty = \"RSA\";\n            break;\n        case \"ES\":\n            kty = \"EC\";\n            break;\n        case \"Ed\":\n            kty = \"OKP\";\n            break;\n        default:\n            throw new UnsupportedOperationError();\n    }\n    const candidates = jwks.keys.filter((jwk)=>{\n        if (jwk.kty !== kty) {\n            return false;\n        }\n        if (kid !== undefined && kid !== jwk.kid) {\n            return false;\n        }\n        if (jwk.alg !== undefined && alg !== jwk.alg) {\n            return false;\n        }\n        if (jwk.use !== undefined && jwk.use !== \"sig\") {\n            return false;\n        }\n        if (jwk.key_ops?.includes(\"verify\") === false) {\n            return false;\n        }\n        switch(true){\n            case alg === \"ES256\" && jwk.crv !== \"P-256\":\n            case alg === \"ES384\" && jwk.crv !== \"P-384\":\n            case alg === \"ES512\" && jwk.crv !== \"P-521\":\n            case alg === \"EdDSA\" && !(jwk.crv === \"Ed25519\" || jwk.crv === \"Ed448\"):\n                return false;\n        }\n        return true;\n    });\n    const { 0: jwk, length } = candidates;\n    if (!length) {\n        if (age >= 60) {\n            jwksCache.delete(as);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n        throw new OPE(\"error when selecting a JWT verification key, no applicable keys found\");\n    } else if (length !== 1) {\n        throw new OPE('error when selecting a JWT verification key, multiple applicable keys found, a \"kid\" JWT Header Parameter is required');\n    }\n    const key = await importJwk(alg, jwk);\n    if (key.type !== \"public\") {\n        throw new OPE(\"jwks_uri must only contain public keys\");\n    }\n    return key;\n}\nconst skipSubjectCheck = Symbol();\nfunction getContentType(response) {\n    return response.headers.get(\"content-type\")?.split(\";\")[0];\n}\nasync function processUserInfoResponse(as, client, expectedSubject, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform UserInfo Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === \"application/jwt\") {\n        assertReadableResponse(response);\n        const { claims } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.userinfo_signed_response_alg, as.userinfo_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(validateOptionalAudience.bind(undefined, client.client_id)).then(validateOptionalIssuer.bind(undefined, as.issuer));\n        json = claims;\n    } else {\n        if (client.userinfo_signed_response_alg) {\n            throw new OPE(\"JWT UserInfo Response expected\");\n        }\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        } catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', {\n                cause\n            });\n        }\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.sub)) {\n        throw new OPE('\"response\" body \"sub\" property must be a non-empty string');\n    }\n    switch(expectedSubject){\n        case skipSubjectCheck:\n            break;\n        default:\n            if (!validateString(expectedSubject)) {\n                throw new OPE('\"expectedSubject\" must be a non-empty string');\n            }\n            if (json.sub !== expectedSubject) {\n                throw new OPE('unexpected \"response\" body \"sub\" value');\n            }\n    }\n    return json;\n}\nasync function authenticatedRequest(as, client, method, url, body, headers, options) {\n    await clientAuthentication(as, client, body, headers, options?.clientPrivateKey);\n    headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\");\n    return fetch(url.href, {\n        body,\n        headers,\n        method,\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function tokenEndpointRequest(as, client, grantType, parameters, options) {\n    if (typeof as.token_endpoint !== \"string\") {\n        throw new TypeError('\"as.token_endpoint\" must be a string');\n    }\n    const url = new URL(as.token_endpoint);\n    parameters.set(\"grant_type\", grantType);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, \"POST\", getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, \"POST\", url, parameters, headers, options);\n}\nasync function refreshTokenGrantRequest(as, client, refreshToken, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(refreshToken)) {\n        throw new TypeError('\"refreshToken\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"refresh_token\", refreshToken);\n    return tokenEndpointRequest(as, client, \"refresh_token\", parameters, options);\n}\nconst idTokenClaims = new WeakMap();\nfunction getValidatedIdTokenClaims(ref) {\n    if (!ref.id_token) {\n        return undefined;\n    }\n    const claims = idTokenClaims.get(ref);\n    if (!claims) {\n        throw new TypeError('\"ref\" was already garbage collected or did not resolve from the proper sources');\n    }\n    return claims;\n}\nasync function processGenericAccessTokenResponse(as, client, response, ignoreIdToken = false, ignoreRefreshToken = false) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Token Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.access_token)) {\n        throw new OPE('\"response\" body \"access_token\" property must be a non-empty string');\n    }\n    if (!validateString(json.token_type)) {\n        throw new OPE('\"response\" body \"token_type\" property must be a non-empty string');\n    }\n    json.token_type = json.token_type.toLowerCase();\n    if (json.token_type !== \"dpop\" && json.token_type !== \"bearer\") {\n        throw new UnsupportedOperationError(\"unsupported `token_type` value\");\n    }\n    if (json.expires_in !== undefined && (typeof json.expires_in !== \"number\" || json.expires_in <= 0)) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (!ignoreRefreshToken && json.refresh_token !== undefined && !validateString(json.refresh_token)) {\n        throw new OPE('\"response\" body \"refresh_token\" property must be a non-empty string');\n    }\n    if (json.scope !== undefined && typeof json.scope !== \"string\") {\n        throw new OPE('\"response\" body \"scope\" property must be a string');\n    }\n    if (!ignoreIdToken) {\n        if (json.id_token !== undefined && !validateString(json.id_token)) {\n            throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n        }\n        if (json.id_token) {\n            const { claims } = await validateJwt(json.id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, [\n                \"aud\",\n                \"exp\",\n                \"iat\",\n                \"iss\",\n                \"sub\"\n            ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n            if (Array.isArray(claims.aud) && claims.aud.length !== 1 && claims.azp !== client.client_id) {\n                throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n            }\n            if (client.require_auth_time && typeof claims.auth_time !== \"number\") {\n                throw new OPE('unexpected ID Token \"auth_time\" (authentication time) claim value');\n            }\n            idTokenClaims.set(json, claims);\n        }\n    }\n    return json;\n}\nasync function processRefreshTokenResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nfunction validateOptionalAudience(expected, result) {\n    if (result.claims.aud !== undefined) {\n        return validateAudience(expected, result);\n    }\n    return result;\n}\nfunction validateAudience(expected, result) {\n    if (Array.isArray(result.claims.aud)) {\n        if (!result.claims.aud.includes(expected)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n        }\n    } else if (result.claims.aud !== expected) {\n        throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n    }\n    return result;\n}\nfunction validateOptionalIssuer(expected, result) {\n    if (result.claims.iss !== undefined) {\n        return validateIssuer(expected, result);\n    }\n    return result;\n}\nfunction validateIssuer(expected, result) {\n    if (result.claims.iss !== expected) {\n        throw new OPE('unexpected JWT \"iss\" (issuer) claim value');\n    }\n    return result;\n}\nconst branded = new WeakSet();\nfunction brand(searchParams) {\n    branded.add(searchParams);\n    return searchParams;\n}\nasync function authorizationCodeGrantRequest(as, client, callbackParameters, redirectUri, codeVerifier, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!branded.has(callbackParameters)) {\n        throw new TypeError('\"callbackParameters\" must be an instance of URLSearchParams obtained from \"validateAuthResponse()\", or \"validateJwtAuthResponse()');\n    }\n    if (!validateString(redirectUri)) {\n        throw new TypeError('\"redirectUri\" must be a non-empty string');\n    }\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    const code = getURLSearchParameter(callbackParameters, \"code\");\n    if (!code) {\n        throw new OPE('no authorization code in \"callbackParameters\"');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"redirect_uri\", redirectUri);\n    parameters.set(\"code_verifier\", codeVerifier);\n    parameters.set(\"code\", code);\n    return tokenEndpointRequest(as, client, \"authorization_code\", parameters, options);\n}\nconst claimNames = {\n    aud: \"audience\",\n    exp: \"expiration time\",\n    iat: \"issued at\",\n    iss: \"issuer\",\n    sub: \"subject\"\n};\nfunction validatePresence(required, result) {\n    for (const claim of required){\n        if (result.claims[claim] === undefined) {\n            throw new OPE(`JWT \"${claim}\" (${claimNames[claim]}) claim missing`);\n        }\n    }\n    return result;\n}\nconst expectNoNonce = Symbol();\nconst skipAuthTimeCheck = Symbol();\nasync function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge) {\n    const result = await processGenericAccessTokenResponse(as, client, response);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (!validateString(result.id_token)) {\n        throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n    }\n    maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n    const claims = getValidatedIdTokenClaims(result);\n    if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) && claims.auth_time === undefined) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        if (typeof maxAge !== \"number\" || maxAge < 0) {\n            throw new TypeError('\"options.max_age\" must be a non-negative number');\n        }\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw new OPE(\"too much time has elapsed since the last End-User authentication\");\n        }\n    }\n    switch(expectedNonce){\n        case undefined:\n        case expectNoNonce:\n            if (claims.nonce !== undefined) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n            break;\n        default:\n            if (!validateString(expectedNonce)) {\n                throw new TypeError('\"expectedNonce\" must be a non-empty string');\n            }\n            if (claims.nonce === undefined) {\n                throw new OPE('ID Token \"nonce\" claim missing');\n            }\n            if (claims.nonce !== expectedNonce) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n    }\n    return result;\n}\nasync function processAuthorizationCodeOAuth2Response(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (result.id_token !== undefined) {\n        if (typeof result.id_token === \"string\" && result.id_token.length) {\n            throw new OPE(\"Unexpected ID Token returned, use processAuthorizationCodeOpenIDResponse() for OpenID Connect callback processing\");\n        }\n        delete result.id_token;\n    }\n    return result;\n}\nfunction checkJwtType(expected, result) {\n    if (typeof result.header.typ !== \"string\" || normalizeTyp(result.header.typ) !== expected) {\n        throw new OPE('unexpected JWT \"typ\" header parameter value');\n    }\n    return result;\n}\nasync function clientCredentialsGrantRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    return tokenEndpointRequest(as, client, \"client_credentials\", new URLSearchParams(parameters), options);\n}\nasync function processClientCredentialsResponse(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    return result;\n}\nasync function revocationRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    if (typeof as.revocation_endpoint !== \"string\") {\n        throw new TypeError('\"as.revocation_endpoint\" must be a string');\n    }\n    const url = new URL(as.revocation_endpoint);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    headers.delete(\"accept\");\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processRevocationResponse(response) {\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Revocation Endpoint response');\n    }\n    return undefined;\n}\nfunction assertReadableResponse(response) {\n    if (response.bodyUsed) {\n        throw new TypeError('\"response\" body has been used already');\n    }\n}\nasync function introspectionRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    if (typeof as.introspection_endpoint !== \"string\") {\n        throw new TypeError('\"as.introspection_endpoint\" must be a string');\n    }\n    const url = new URL(as.introspection_endpoint);\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set(\"token\", token);\n    const headers = prepareHeaders(options?.headers);\n    if (options?.requestJwtResponse ?? client.introspection_signed_response_alg) {\n        headers.set(\"accept\", \"application/token-introspection+jwt\");\n    } else {\n        headers.set(\"accept\", \"application/json\");\n    }\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processIntrospectionResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Introspection Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === \"application/token-introspection+jwt\") {\n        assertReadableResponse(response);\n        const { claims } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.introspection_signed_response_alg, as.introspection_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(checkJwtType.bind(undefined, \"token-introspection+jwt\")).then(validatePresence.bind(undefined, [\n            \"aud\",\n            \"iat\",\n            \"iss\"\n        ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n        json = claims.token_introspection;\n        if (!isJsonObject(json)) {\n            throw new OPE('JWT \"token_introspection\" claim must be a JSON object');\n        }\n    } else {\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        } catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', {\n                cause\n            });\n        }\n        if (!isJsonObject(json)) {\n            throw new OPE('\"response\" body must be a top level object');\n        }\n    }\n    if (typeof json.active !== \"boolean\") {\n        throw new OPE('\"response\" body \"active\" property must be a boolean');\n    }\n    return json;\n}\nasync function jwksRequest(as, options) {\n    assertAs(as);\n    if (typeof as.jwks_uri !== \"string\") {\n        throw new TypeError('\"as.jwks_uri\" must be a string');\n    }\n    const url = new URL(as.jwks_uri);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    headers.append(\"accept\", \"application/jwk-set+json\");\n    return fetch(url.href, {\n        headers,\n        method: \"GET\",\n        redirect: \"manual\",\n        signal: options?.signal ? signal(options.signal) : null\n    }).then(processDpopNonce);\n}\nasync function processJwksResponse(response) {\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform JSON Web Key Set response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!Array.isArray(json.keys)) {\n        throw new OPE('\"response\" body \"keys\" property must be an array');\n    }\n    if (!Array.prototype.every.call(json.keys, isJsonObject)) {\n        throw new OPE('\"response\" body \"keys\" property members must be JWK formatted objects');\n    }\n    return json;\n}\nasync function handleOAuthBodyError(response) {\n    if (response.status > 399 && response.status < 500) {\n        assertReadableResponse(response);\n        try {\n            const json = await response.json();\n            if (isJsonObject(json) && typeof json.error === \"string\" && json.error.length) {\n                if (json.error_description !== undefined && typeof json.error_description !== \"string\") {\n                    delete json.error_description;\n                }\n                if (json.error_uri !== undefined && typeof json.error_uri !== \"string\") {\n                    delete json.error_uri;\n                }\n                if (json.algs !== undefined && typeof json.algs !== \"string\") {\n                    delete json.algs;\n                }\n                if (json.scope !== undefined && typeof json.scope !== \"string\") {\n                    delete json.scope;\n                }\n                return json;\n            }\n        } catch  {}\n    }\n    return undefined;\n}\nfunction checkSupportedJwsAlg(alg) {\n    if (!SUPPORTED_JWS_ALGS.includes(alg)) {\n        throw new UnsupportedOperationError('unsupported JWS \"alg\" identifier');\n    }\n    return alg;\n}\nfunction checkRsaKeyAlgorithm(algorithm) {\n    if (typeof algorithm.modulusLength !== \"number\" || algorithm.modulusLength < 2048) {\n        throw new OPE(`${algorithm.name} modulusLength must be at least 2048 bits`);\n    }\n}\nfunction ecdsaHashName(namedCurve) {\n    switch(namedCurve){\n        case \"P-256\":\n            return \"SHA-256\";\n        case \"P-384\":\n            return \"SHA-384\";\n        case \"P-521\":\n            return \"SHA-512\";\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nfunction keyToSubtle(key) {\n    switch(key.algorithm.name){\n        case \"ECDSA\":\n            return {\n                name: key.algorithm.name,\n                hash: ecdsaHashName(key.algorithm.namedCurve)\n            };\n        case \"RSA-PSS\":\n            {\n                checkRsaKeyAlgorithm(key.algorithm);\n                switch(key.algorithm.hash.name){\n                    case \"SHA-256\":\n                    case \"SHA-384\":\n                    case \"SHA-512\":\n                        return {\n                            name: key.algorithm.name,\n                            saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3\n                        };\n                    default:\n                        throw new UnsupportedOperationError();\n                }\n            }\n        case \"RSASSA-PKCS1-v1_5\":\n            checkRsaKeyAlgorithm(key.algorithm);\n            return key.algorithm.name;\n        case \"Ed448\":\n        case \"Ed25519\":\n            return key.algorithm.name;\n    }\n    throw new UnsupportedOperationError();\n}\nconst noSignatureCheck = Symbol();\nasync function validateJwt(jws, checkAlg, getKey, clockSkew, clockTolerance) {\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature, length } = jws.split(\".\");\n    if (length === 5) {\n        throw new UnsupportedOperationError(\"JWE structure JWTs are not supported\");\n    }\n    if (length !== 3) {\n        throw new OPE(\"Invalid JWT\");\n    }\n    let header;\n    try {\n        header = JSON.parse(buf(b64u(protectedHeader)));\n    } catch (cause) {\n        throw new OPE(\"failed to parse JWT Header body as base64url encoded JSON\", {\n            cause\n        });\n    }\n    if (!isJsonObject(header)) {\n        throw new OPE(\"JWT Header must be a top level object\");\n    }\n    checkAlg(header);\n    if (header.crit !== undefined) {\n        throw new OPE('unexpected JWT \"crit\" header parameter');\n    }\n    const signature = b64u(encodedSignature);\n    if (getKey !== noSignatureCheck) {\n        const key = await getKey(header);\n        const input = `${protectedHeader}.${payload}`;\n        const verified = await crypto.subtle.verify(keyToSubtle(key), key, signature, buf(input));\n        if (!verified) {\n            throw new OPE(\"JWT signature verification failed\");\n        }\n    }\n    let claims;\n    try {\n        claims = JSON.parse(buf(b64u(payload)));\n    } catch (cause) {\n        throw new OPE(\"failed to parse JWT Payload body as base64url encoded JSON\", {\n            cause\n        });\n    }\n    if (!isJsonObject(claims)) {\n        throw new OPE(\"JWT Payload must be a top level object\");\n    }\n    const now = epochTime() + clockSkew;\n    if (claims.exp !== undefined) {\n        if (typeof claims.exp !== \"number\") {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim type');\n        }\n        if (claims.exp <= now - clockTolerance) {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim value, timestamp is <= now()');\n        }\n    }\n    if (claims.iat !== undefined) {\n        if (typeof claims.iat !== \"number\") {\n            throw new OPE('unexpected JWT \"iat\" (issued at) claim type');\n        }\n    }\n    if (claims.iss !== undefined) {\n        if (typeof claims.iss !== \"string\") {\n            throw new OPE('unexpected JWT \"iss\" (issuer) claim type');\n        }\n    }\n    if (claims.nbf !== undefined) {\n        if (typeof claims.nbf !== \"number\") {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim type');\n        }\n        if (claims.nbf > now + clockTolerance) {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim value, timestamp is > now()');\n        }\n    }\n    if (claims.aud !== undefined) {\n        if (typeof claims.aud !== \"string\" && !Array.isArray(claims.aud)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim type');\n        }\n    }\n    return {\n        header,\n        claims,\n        signature\n    };\n}\nasync function validateJwtAuthResponse(as, client, parameters, expectedState, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    const response = getURLSearchParameter(parameters, \"response\");\n    if (!response) {\n        throw new OPE('\"parameters\" does not contain a JARM response');\n    }\n    if (typeof as.jwks_uri !== \"string\") {\n        throw new TypeError('\"as.jwks_uri\" must be a string');\n    }\n    const { claims } = await validateJwt(response, checkSigningAlgorithm.bind(undefined, client.authorization_signed_response_alg, as.authorization_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, [\n        \"aud\",\n        \"exp\",\n        \"iss\"\n    ])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n    const result = new URLSearchParams();\n    for (const [key, value] of Object.entries(claims)){\n        if (typeof value === \"string\" && key !== \"aud\") {\n            result.set(key, value);\n        }\n    }\n    return validateAuthResponse(as, client, result, expectedState);\n}\nfunction checkSigningAlgorithm(client, issuer, header) {\n    if (client !== undefined) {\n        if (header.alg !== client) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (Array.isArray(issuer)) {\n        if (!issuer.includes(header.alg)) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (header.alg !== \"RS256\") {\n        throw new OPE('unexpected JWT \"alg\" header parameter');\n    }\n}\nfunction getURLSearchParameter(parameters, name) {\n    const { 0: value, length } = parameters.getAll(name);\n    if (length > 1) {\n        throw new OPE(`\"${name}\" parameter must be provided only once`);\n    }\n    return value;\n}\nconst skipStateCheck = Symbol();\nconst expectNoState = Symbol();\nfunction validateAuthResponse(as, client, parameters, expectedState) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    if (getURLSearchParameter(parameters, \"response\")) {\n        throw new OPE('\"parameters\" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');\n    }\n    const iss = getURLSearchParameter(parameters, \"iss\");\n    const state = getURLSearchParameter(parameters, \"state\");\n    if (!iss && as.authorization_response_iss_parameter_supported) {\n        throw new OPE('response parameter \"iss\" (issuer) missing');\n    }\n    if (iss && iss !== as.issuer) {\n        throw new OPE('unexpected \"iss\" (issuer) response parameter value');\n    }\n    switch(expectedState){\n        case undefined:\n        case expectNoState:\n            if (state !== undefined) {\n                throw new OPE('unexpected \"state\" response parameter encountered');\n            }\n            break;\n        case skipStateCheck:\n            break;\n        default:\n            if (!validateString(expectedState)) {\n                throw new OPE('\"expectedState\" must be a non-empty string');\n            }\n            if (state === undefined) {\n                throw new OPE('response parameter \"state\" missing');\n            }\n            if (state !== expectedState) {\n                throw new OPE('unexpected \"state\" response parameter value');\n            }\n    }\n    const error = getURLSearchParameter(parameters, \"error\");\n    if (error) {\n        return {\n            error,\n            error_description: getURLSearchParameter(parameters, \"error_description\"),\n            error_uri: getURLSearchParameter(parameters, \"error_uri\")\n        };\n    }\n    const id_token = getURLSearchParameter(parameters, \"id_token\");\n    const token = getURLSearchParameter(parameters, \"token\");\n    if (id_token !== undefined || token !== undefined) {\n        throw new UnsupportedOperationError(\"implicit and hybrid flows are not supported\");\n    }\n    return brand(new URLSearchParams(parameters));\n}\nfunction algToSubtle(alg, crv) {\n    switch(alg){\n        case \"PS256\":\n        case \"PS384\":\n        case \"PS512\":\n            return {\n                name: \"RSA-PSS\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"RS256\":\n        case \"RS384\":\n        case \"RS512\":\n            return {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: `SHA-${alg.slice(-3)}`\n            };\n        case \"ES256\":\n        case \"ES384\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: `P-${alg.slice(-3)}`\n            };\n        case \"ES512\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: \"P-521\"\n            };\n        case \"EdDSA\":\n            {\n                switch(crv){\n                    case \"Ed25519\":\n                    case \"Ed448\":\n                        return crv;\n                    default:\n                        throw new UnsupportedOperationError();\n                }\n            }\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nasync function importJwk(alg, jwk) {\n    const { ext, key_ops, use, ...key } = jwk;\n    return crypto.subtle.importKey(\"jwk\", key, algToSubtle(alg, jwk.crv), true, [\n        \"verify\"\n    ]);\n}\nasync function deviceAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    if (typeof as.device_authorization_endpoint !== \"string\") {\n        throw new TypeError('\"as.device_authorization_endpoint\" must be a string');\n    }\n    const url = new URL(as.device_authorization_endpoint);\n    const body = new URLSearchParams(parameters);\n    body.set(\"client_id\", client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set(\"accept\", \"application/json\");\n    return authenticatedRequest(as, client, \"POST\", url, body, headers, options);\n}\nasync function processDeviceAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!(response instanceof Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if (err = await handleOAuthBodyError(response)) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Device Authorization Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    } catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', {\n            cause\n        });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.device_code)) {\n        throw new OPE('\"response\" body \"device_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.user_code)) {\n        throw new OPE('\"response\" body \"user_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.verification_uri)) {\n        throw new OPE('\"response\" body \"verification_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== \"number\" || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (json.verification_uri_complete !== undefined && !validateString(json.verification_uri_complete)) {\n        throw new OPE('\"response\" body \"verification_uri_complete\" property must be a non-empty string');\n    }\n    if (json.interval !== undefined && (typeof json.interval !== \"number\" || json.interval <= 0)) {\n        throw new OPE('\"response\" body \"interval\" property must be a positive number');\n    }\n    return json;\n}\nasync function deviceCodeGrantRequest(as, client, deviceCode, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(deviceCode)) {\n        throw new TypeError('\"deviceCode\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set(\"device_code\", deviceCode);\n    return tokenEndpointRequest(as, client, \"urn:ietf:params:oauth:grant-type:device_code\", parameters, options);\n}\nasync function processDeviceCodeResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nasync function generateKeyPair(alg, options) {\n    if (!validateString(alg)) {\n        throw new TypeError('\"alg\" must be a non-empty string');\n    }\n    const algorithm = algToSubtle(alg, alg === \"EdDSA\" ? options?.crv ?? \"Ed25519\" : undefined);\n    if (alg.startsWith(\"PS\") || alg.startsWith(\"RS\")) {\n        Object.assign(algorithm, {\n            modulusLength: options?.modulusLength ?? 2048,\n            publicExponent: new Uint8Array([\n                0x01,\n                0x00,\n                0x01\n            ])\n        });\n    }\n    return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, [\n        \"sign\",\n        \"verify\"\n    ]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb2F1dGg0d2ViYXBpL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBO0FBQ0osSUFBSSxPQUFPQyxjQUFjLGVBQWUsQ0FBQ0EsVUFBVUMsU0FBUyxFQUFFQyxhQUFhLGlCQUFpQjtJQUN4RixNQUFNQyxPQUFPO0lBQ2IsTUFBTUMsVUFBVTtJQUNoQkwsYUFBYSxDQUFDLEVBQUVJLEtBQUssQ0FBQyxFQUFFQyxRQUFRLENBQUM7QUFDckM7QUFDTyxNQUFNQyxZQUFZQyxTQUFTO0FBQzNCLE1BQU1DLGlCQUFpQkQsU0FBUztBQUN2QyxNQUFNRSxVQUFVLElBQUlDO0FBQ3BCLE1BQU1DLFVBQVUsSUFBSUM7QUFDcEIsU0FBU0MsSUFBSUMsS0FBSztJQUNkLElBQUksT0FBT0EsVUFBVSxVQUFVO1FBQzNCLE9BQU9MLFFBQVFNLE1BQU0sQ0FBQ0Q7SUFDMUI7SUFDQSxPQUFPSCxRQUFRSyxNQUFNLENBQUNGO0FBQzFCO0FBQ0EsTUFBTUcsYUFBYTtBQUNuQixTQUFTQyxnQkFBZ0JKLEtBQUs7SUFDMUIsSUFBSUEsaUJBQWlCSyxhQUFhO1FBQzlCTCxRQUFRLElBQUlNLFdBQVdOO0lBQzNCO0lBQ0EsTUFBTU8sTUFBTSxFQUFFO0lBQ2QsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlSLE1BQU1TLFVBQVUsRUFBRUQsS0FBS0wsV0FBWTtRQUNuREksSUFBSUcsSUFBSSxDQUFDQyxPQUFPQyxZQUFZLENBQUNDLEtBQUssQ0FBQyxNQUFNYixNQUFNYyxRQUFRLENBQUNOLEdBQUdBLElBQUlMO0lBQ25FO0lBQ0EsT0FBT1ksS0FBS1IsSUFBSVMsSUFBSSxDQUFDLEtBQUtDLE9BQU8sQ0FBQyxNQUFNLElBQUlBLE9BQU8sQ0FBQyxPQUFPLEtBQUtBLE9BQU8sQ0FBQyxPQUFPO0FBQ25GO0FBQ0EsU0FBU0MsZ0JBQWdCbEIsS0FBSztJQUMxQixJQUFJO1FBQ0EsTUFBTW1CLFNBQVNDLEtBQUtwQixNQUFNaUIsT0FBTyxDQUFDLE1BQU0sS0FBS0EsT0FBTyxDQUFDLE1BQU0sS0FBS0EsT0FBTyxDQUFDLE9BQU87UUFDL0UsTUFBTUksUUFBUSxJQUFJZixXQUFXYSxPQUFPRyxNQUFNO1FBQzFDLElBQUssSUFBSWQsSUFBSSxHQUFHQSxJQUFJVyxPQUFPRyxNQUFNLEVBQUVkLElBQUs7WUFDcENhLEtBQUssQ0FBQ2IsRUFBRSxHQUFHVyxPQUFPSSxVQUFVLENBQUNmO1FBQ2pDO1FBQ0EsT0FBT2E7SUFDWCxFQUNBLE9BQU9HLE9BQU87UUFDVixNQUFNLElBQUlDLElBQUkscURBQXFEO1lBQUVEO1FBQU07SUFDL0U7QUFDSjtBQUNBLFNBQVNFLEtBQUsxQixLQUFLO0lBQ2YsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsT0FBT2tCLGdCQUFnQmxCO0lBQzNCO0lBQ0EsT0FBT0ksZ0JBQWdCSjtBQUMzQjtBQUNBLE1BQU0yQjtJQUNGQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsSUFBSSxDQUFDQyxLQUFLLEdBQUcsSUFBSUM7UUFDakIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSUQ7UUFDbEIsSUFBSSxDQUFDRixPQUFPLEdBQUdBO0lBQ25CO0lBQ0FJLElBQUlDLEdBQUcsRUFBRTtRQUNMLElBQUlDLElBQUksSUFBSSxDQUFDTCxLQUFLLENBQUNHLEdBQUcsQ0FBQ0M7UUFDdkIsSUFBSUMsR0FBRztZQUNILE9BQU9BO1FBQ1g7UUFDQSxJQUFLQSxJQUFJLElBQUksQ0FBQ0gsTUFBTSxDQUFDQyxHQUFHLENBQUNDLE1BQU87WUFDNUIsSUFBSSxDQUFDRSxNQUFNLENBQUNGLEtBQUtDO1lBQ2pCLE9BQU9BO1FBQ1g7UUFDQSxPQUFPRTtJQUNYO0lBQ0FDLElBQUlKLEdBQUcsRUFBRTtRQUNMLE9BQU8sSUFBSSxDQUFDSixLQUFLLENBQUNRLEdBQUcsQ0FBQ0osUUFBUSxJQUFJLENBQUNGLE1BQU0sQ0FBQ00sR0FBRyxDQUFDSjtJQUNsRDtJQUNBSyxJQUFJTCxHQUFHLEVBQUVNLEtBQUssRUFBRTtRQUNaLElBQUksSUFBSSxDQUFDVixLQUFLLENBQUNRLEdBQUcsQ0FBQ0osTUFBTTtZQUNyQixJQUFJLENBQUNKLEtBQUssQ0FBQ1MsR0FBRyxDQUFDTCxLQUFLTTtRQUN4QixPQUNLO1lBQ0QsSUFBSSxDQUFDSixNQUFNLENBQUNGLEtBQUtNO1FBQ3JCO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMsT0FBT1AsR0FBRyxFQUFFO1FBQ1IsSUFBSSxJQUFJLENBQUNKLEtBQUssQ0FBQ1EsR0FBRyxDQUFDSixNQUFNO1lBQ3JCLE9BQU8sSUFBSSxDQUFDSixLQUFLLENBQUNXLE1BQU0sQ0FBQ1A7UUFDN0I7UUFDQSxJQUFJLElBQUksQ0FBQ0YsTUFBTSxDQUFDTSxHQUFHLENBQUNKLE1BQU07WUFDdEIsT0FBTyxJQUFJLENBQUNGLE1BQU0sQ0FBQ1MsTUFBTSxDQUFDUDtRQUM5QjtRQUNBLE9BQU87SUFDWDtJQUNBRSxPQUFPRixHQUFHLEVBQUVNLEtBQUssRUFBRTtRQUNmLElBQUksQ0FBQ1YsS0FBSyxDQUFDUyxHQUFHLENBQUNMLEtBQUtNO1FBQ3BCLElBQUksSUFBSSxDQUFDVixLQUFLLENBQUNZLElBQUksSUFBSSxJQUFJLENBQUNiLE9BQU8sRUFBRTtZQUNqQyxJQUFJLENBQUNHLE1BQU0sR0FBRyxJQUFJLENBQUNGLEtBQUs7WUFDeEIsSUFBSSxDQUFDQSxLQUFLLEdBQUcsSUFBSUM7UUFDckI7SUFDSjtBQUNKO0FBQ08sTUFBTVksa0NBQWtDQztJQUMzQ2hCLFlBQVlpQixPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQSxXQUFXO1FBQ2pCLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUksQ0FBQ2xCLFdBQVcsQ0FBQ2tCLElBQUk7UUFDakNGLE1BQU1HLGlCQUFpQixHQUFHLElBQUksRUFBRSxJQUFJLENBQUNuQixXQUFXO0lBQ3BEO0FBQ0o7QUFDTyxNQUFNb0IsaUNBQWlDSjtJQUMxQ2hCLFlBQVlpQixPQUFPLEVBQUVJLE9BQU8sQ0FBRTtRQUMxQixLQUFLLENBQUNKLFNBQVNJO1FBQ2YsSUFBSSxDQUFDSCxJQUFJLEdBQUcsSUFBSSxDQUFDbEIsV0FBVyxDQUFDa0IsSUFBSTtRQUNqQ0YsTUFBTUcsaUJBQWlCLEdBQUcsSUFBSSxFQUFFLElBQUksQ0FBQ25CLFdBQVc7SUFDcEQ7QUFDSjtBQUNBLE1BQU1ILE1BQU11QjtBQUNaLE1BQU1FLGFBQWEsSUFBSXZCLElBQUk7QUFDM0IsU0FBU3dCLFlBQVlqQixHQUFHO0lBQ3BCLE9BQU9BLGVBQWVrQjtBQUMxQjtBQUNBLFNBQVNDLGFBQWFuQixHQUFHO0lBQ3JCLE9BQU9pQixZQUFZakIsUUFBUUEsSUFBSW9CLElBQUksS0FBSztBQUM1QztBQUNBLFNBQVNDLFlBQVlyQixHQUFHO0lBQ3BCLE9BQU9pQixZQUFZakIsUUFBUUEsSUFBSW9CLElBQUksS0FBSztBQUM1QztBQUNBLE1BQU1FLHFCQUFxQjtJQUN2QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsU0FBU0MsaUJBQWlCQyxRQUFRO0lBQzlCLE1BQU1DLE1BQU0sSUFBSUMsSUFBSUYsU0FBU0MsR0FBRztJQUNoQyxJQUFJRCxTQUFTRyxPQUFPLENBQUN2QixHQUFHLENBQUMsZUFBZTtRQUNwQ1ksV0FBV1gsR0FBRyxDQUFDb0IsSUFBSUcsTUFBTSxFQUFFSixTQUFTRyxPQUFPLENBQUM1QixHQUFHLENBQUM7SUFDcEQ7SUFDQSxPQUFPeUI7QUFDWDtBQUNBLFNBQVNLLGFBQWF2QixLQUFLO0lBQ3ZCLE9BQU9BLE1BQU13QixXQUFXLEdBQUcvQyxPQUFPLENBQUMsa0JBQWtCO0FBQ3pEO0FBQ0EsU0FBU2dELGFBQWFqRSxLQUFLO0lBQ3ZCLElBQUlBLFVBQVUsUUFBUSxPQUFPQSxVQUFVLFlBQVlrRSxNQUFNQyxPQUFPLENBQUNuRSxRQUFRO1FBQ3JFLE9BQU87SUFDWDtJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVNvRSxlQUFlcEUsS0FBSztJQUN6QixJQUFJQSxVQUFVcUMsYUFBYSxDQUFFckMsQ0FBQUEsaUJBQWlCcUUsT0FBTSxHQUFJO1FBQ3BELE1BQU0sSUFBSUMsVUFBVTtJQUN4QjtJQUNBLE1BQU1ULFVBQVUsSUFBSVEsUUFBUXJFO0lBQzVCLElBQUlkLGNBQWMsQ0FBQzJFLFFBQVF2QixHQUFHLENBQUMsZUFBZTtRQUMxQ3VCLFFBQVF0QixHQUFHLENBQUMsY0FBY3JEO0lBQzlCO0lBQ0EsSUFBSTJFLFFBQVF2QixHQUFHLENBQUMsa0JBQWtCO1FBQzlCLE1BQU0sSUFBSWdDLFVBQVU7SUFDeEI7SUFDQSxJQUFJVCxRQUFRdkIsR0FBRyxDQUFDLFNBQVM7UUFDckIsTUFBTSxJQUFJZ0MsVUFBVTtJQUN4QjtJQUNBLE9BQU9UO0FBQ1g7QUFDQSxTQUFTVSxPQUFPL0IsS0FBSztJQUNqQixJQUFJLE9BQU9BLFVBQVUsWUFBWTtRQUM3QkEsUUFBUUE7SUFDWjtJQUNBLElBQUksQ0FBRUEsQ0FBQUEsaUJBQWlCZ0MsV0FBVSxHQUFJO1FBQ2pDLE1BQU0sSUFBSUYsVUFBVTtJQUN4QjtJQUNBLE9BQU85QjtBQUNYO0FBQ08sZUFBZWlDLGlCQUFpQkMsZ0JBQWdCLEVBQUV6QixPQUFPO0lBQzVELElBQUksQ0FBRXlCLENBQUFBLDRCQUE0QmQsR0FBRSxHQUFJO1FBQ3BDLE1BQU0sSUFBSVUsVUFBVTtJQUN4QjtJQUNBLElBQUlJLGlCQUFpQkMsUUFBUSxLQUFLLFlBQVlELGlCQUFpQkMsUUFBUSxLQUFLLFNBQVM7UUFDakYsTUFBTSxJQUFJTCxVQUFVO0lBQ3hCO0lBQ0EsTUFBTVgsTUFBTSxJQUFJQyxJQUFJYyxpQkFBaUJFLElBQUk7SUFDekMsT0FBUTNCLFNBQVM0QjtRQUNiLEtBQUt4QztRQUNMLEtBQUs7WUFDRHNCLElBQUltQixRQUFRLEdBQUcsQ0FBQyxFQUFFbkIsSUFBSW1CLFFBQVEsQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDN0QsT0FBTyxDQUFDLE1BQU07WUFDaEY7UUFDSixLQUFLO1lBQ0QsSUFBSTBDLElBQUltQixRQUFRLEtBQUssS0FBSztnQkFDdEJuQixJQUFJbUIsUUFBUSxHQUFHLENBQUMsc0NBQXNDLENBQUM7WUFDM0QsT0FDSztnQkFDRG5CLElBQUltQixRQUFRLEdBQUcsQ0FBQyx1Q0FBdUMsRUFBRW5CLElBQUltQixRQUFRLENBQUMsQ0FBQyxDQUFDN0QsT0FBTyxDQUFDLE1BQU07WUFDMUY7WUFDQTtRQUNKO1lBQ0ksTUFBTSxJQUFJcUQsVUFBVTtJQUM1QjtJQUNBLE1BQU1ULFVBQVVPLGVBQWVuQixTQUFTWTtJQUN4Q0EsUUFBUXRCLEdBQUcsQ0FBQyxVQUFVO0lBQ3RCLE9BQU93QyxNQUFNcEIsSUFBSWlCLElBQUksRUFBRTtRQUNuQmY7UUFDQW1CLFFBQVE7UUFDUkMsVUFBVTtRQUNWVixRQUFRdEIsU0FBU3NCLFNBQVNBLE9BQU90QixRQUFRc0IsTUFBTSxJQUFJO0lBQ3ZELEdBQUdXLElBQUksQ0FBQ3pCO0FBQ1o7QUFDQSxTQUFTMEIsZUFBZW5GLEtBQUs7SUFDekIsT0FBTyxPQUFPQSxVQUFVLFlBQVlBLE1BQU1zQixNQUFNLEtBQUs7QUFDekQ7QUFDTyxlQUFlOEQseUJBQXlCQyx3QkFBd0IsRUFBRTNCLFFBQVE7SUFDN0UsSUFBSSxDQUFFMkIsQ0FBQUEsb0NBQW9DekIsR0FBRSxHQUFJO1FBQzVDLE1BQU0sSUFBSVUsVUFBVTtJQUN4QjtJQUNBLElBQUksQ0FBRVosQ0FBQUEsb0JBQW9CNEIsUUFBTyxHQUFJO1FBQ2pDLE1BQU0sSUFBSWhCLFVBQVU7SUFDeEI7SUFDQSxJQUFJWixTQUFTNkIsTUFBTSxLQUFLLEtBQUs7UUFDekIsTUFBTSxJQUFJOUQsSUFBSTtJQUNsQjtJQUNBK0QsdUJBQXVCOUI7SUFDdkIsSUFBSStCO0lBQ0osSUFBSTtRQUNBQSxPQUFPLE1BQU0vQixTQUFTK0IsSUFBSTtJQUM5QixFQUNBLE9BQU9qRSxPQUFPO1FBQ1YsTUFBTSxJQUFJQyxJQUFJLDJDQUEyQztZQUFFRDtRQUFNO0lBQ3JFO0lBQ0EsSUFBSSxDQUFDeUMsYUFBYXdCLE9BQU87UUFDckIsTUFBTSxJQUFJaEUsSUFBSTtJQUNsQjtJQUNBLElBQUksQ0FBQzBELGVBQWVNLEtBQUtDLE1BQU0sR0FBRztRQUM5QixNQUFNLElBQUlqRSxJQUFJO0lBQ2xCO0lBQ0EsSUFBSSxJQUFJbUMsSUFBSTZCLEtBQUtDLE1BQU0sRUFBRWQsSUFBSSxLQUFLUyx5QkFBeUJULElBQUksRUFBRTtRQUM3RCxNQUFNLElBQUluRCxJQUFJO0lBQ2xCO0lBQ0EsT0FBT2dFO0FBQ1g7QUFDQSxTQUFTRTtJQUNMLE9BQU9qRSxLQUFLa0UsT0FBT0MsZUFBZSxDQUFDLElBQUl2RixXQUFXO0FBQ3REO0FBQ08sU0FBU3dGO0lBQ1osT0FBT0g7QUFDWDtBQUNPLFNBQVNJO0lBQ1osT0FBT0o7QUFDWDtBQUNPLFNBQVNLO0lBQ1osT0FBT0w7QUFDWDtBQUNPLGVBQWVNLDJCQUEyQkMsWUFBWTtJQUN6RCxJQUFJLENBQUNmLGVBQWVlLGVBQWU7UUFDL0IsTUFBTSxJQUFJNUIsVUFBVTtJQUN4QjtJQUNBLE9BQU81QyxLQUFLLE1BQU1rRSxPQUFPTyxNQUFNLENBQUNDLE1BQU0sQ0FBQyxXQUFXckcsSUFBSW1HO0FBQzFEO0FBQ0EsU0FBU0csYUFBYXJHLEtBQUs7SUFDdkIsSUFBSUEsaUJBQWlCb0QsV0FBVztRQUM1QixPQUFPO1lBQUVsQixLQUFLbEM7UUFBTTtJQUN4QjtJQUNBLElBQUksQ0FBRUEsQ0FBQUEsT0FBT2tDLGVBQWVrQixTQUFRLEdBQUk7UUFDcEMsT0FBTyxDQUFDO0lBQ1o7SUFDQSxJQUFJcEQsTUFBTXNHLEdBQUcsS0FBS2pFLGFBQWEsQ0FBQzhDLGVBQWVuRixNQUFNc0csR0FBRyxHQUFHO1FBQ3ZELE1BQU0sSUFBSWhDLFVBQVU7SUFDeEI7SUFDQSxPQUFPO1FBQUVwQyxLQUFLbEMsTUFBTWtDLEdBQUc7UUFBRW9FLEtBQUt0RyxNQUFNc0csR0FBRztJQUFDO0FBQzVDO0FBQ0EsU0FBU0MsY0FBY0MsS0FBSztJQUN4QixPQUFPQyxtQkFBbUJELE9BQU92RixPQUFPLENBQUMsUUFBUTtBQUNyRDtBQUNBLFNBQVN5RixrQkFBa0JDLFFBQVEsRUFBRUMsWUFBWTtJQUM3QyxNQUFNQyxXQUFXTixjQUFjSTtJQUMvQixNQUFNRyxXQUFXUCxjQUFjSztJQUMvQixNQUFNRyxjQUFjaEcsS0FBSyxDQUFDLEVBQUU4RixTQUFTLENBQUMsRUFBRUMsU0FBUyxDQUFDO0lBQ2xELE9BQU8sQ0FBQyxNQUFNLEVBQUVDLFlBQVksQ0FBQztBQUNqQztBQUNBLFNBQVNDLE1BQU05RSxHQUFHO0lBQ2QsT0FBUUEsSUFBSTJDLFNBQVMsQ0FBQ29DLElBQUksQ0FBQ25FLElBQUk7UUFDM0IsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO1FBQ1g7WUFDSSxNQUFNLElBQUlILDBCQUEwQjtJQUM1QztBQUNKO0FBQ0EsU0FBU3VFLE1BQU1oRixHQUFHO0lBQ2QsT0FBUUEsSUFBSTJDLFNBQVMsQ0FBQ29DLElBQUksQ0FBQ25FLElBQUk7UUFDM0IsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO1FBQ1g7WUFDSSxNQUFNLElBQUlILDBCQUEwQjtJQUM1QztBQUNKO0FBQ0EsU0FBU3dFLE1BQU1qRixHQUFHO0lBQ2QsT0FBUUEsSUFBSTJDLFNBQVMsQ0FBQ3VDLFVBQVU7UUFDNUIsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO1FBQ1g7WUFDSSxNQUFNLElBQUl6RSwwQkFBMEI7SUFDNUM7QUFDSjtBQUNBLFNBQVMwRSxTQUFTbkYsR0FBRztJQUNqQixPQUFRQSxJQUFJMkMsU0FBUyxDQUFDL0IsSUFBSTtRQUN0QixLQUFLO1lBQ0QsT0FBT2tFLE1BQU05RTtRQUNqQixLQUFLO1lBQ0QsT0FBT2dGLE1BQU1oRjtRQUNqQixLQUFLO1lBQ0QsT0FBT2lGLE1BQU1qRjtRQUNqQixLQUFLO1FBQ0wsS0FBSztZQUNELE9BQU87UUFDWDtZQUNJLE1BQU0sSUFBSVMsMEJBQTBCO0lBQzVDO0FBQ0o7QUFDQSxTQUFTMkUsYUFBYUMsTUFBTTtJQUN4QixJQUFJQyxPQUFPQyxRQUFRLENBQUNGLE1BQU0sQ0FBQy9ILFVBQVUsR0FBRztRQUNwQyxPQUFPK0gsTUFBTSxDQUFDL0gsVUFBVTtJQUM1QjtJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVNrSSxrQkFBa0JILE1BQU07SUFDN0IsTUFBTUksWUFBWUosTUFBTSxDQUFDN0gsZUFBZTtJQUN4QyxJQUFJOEgsT0FBT0MsUUFBUSxDQUFDRSxjQUFjQyxLQUFLQyxJQUFJLENBQUNGLGVBQWUsQ0FBQyxHQUFHO1FBQzNELE9BQU9BO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTRztJQUNMLE9BQU9GLEtBQUtHLEtBQUssQ0FBQ0MsS0FBS0MsR0FBRyxLQUFLO0FBQ25DO0FBQ0EsU0FBU0MsZ0JBQWdCQyxFQUFFLEVBQUVaLE1BQU07SUFDL0IsTUFBTVUsTUFBTUgsY0FBY1IsYUFBYUM7SUFDdkMsT0FBTztRQUNIYSxLQUFLekM7UUFDTDBDLEtBQUs7WUFBQ0YsR0FBR3pDLE1BQU07WUFBRXlDLEdBQUdHLGNBQWM7U0FBQztRQUNuQ0MsS0FBS04sTUFBTTtRQUNYTyxLQUFLUDtRQUNMUSxLQUFLUjtRQUNMUyxLQUFLbkIsT0FBT29CLFNBQVM7UUFDckJDLEtBQUtyQixPQUFPb0IsU0FBUztJQUN6QjtBQUNKO0FBQ0EsZUFBZUUsY0FBY1YsRUFBRSxFQUFFWixNQUFNLEVBQUVyRixHQUFHLEVBQUVvRSxHQUFHO0lBQzdDLE9BQU93QyxJQUFJO1FBQ1BDLEtBQUsxQixTQUFTbkY7UUFDZG9FO0lBQ0osR0FBRzRCLGdCQUFnQkMsSUFBSVosU0FBU3JGO0FBQ3BDO0FBQ0EsU0FBUzhHLFNBQVNiLEVBQUU7SUFDaEIsSUFBSSxPQUFPQSxPQUFPLFlBQVlBLE9BQU8sTUFBTTtRQUN2QyxNQUFNLElBQUk3RCxVQUFVO0lBQ3hCO0lBQ0EsSUFBSSxDQUFDYSxlQUFlZ0QsR0FBR3pDLE1BQU0sR0FBRztRQUM1QixNQUFNLElBQUlwQixVQUFVO0lBQ3hCO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBUzJFLGFBQWExQixNQUFNO0lBQ3hCLElBQUksT0FBT0EsV0FBVyxZQUFZQSxXQUFXLE1BQU07UUFDL0MsTUFBTSxJQUFJakQsVUFBVTtJQUN4QjtJQUNBLElBQUksQ0FBQ2EsZUFBZW9DLE9BQU9vQixTQUFTLEdBQUc7UUFDbkMsTUFBTSxJQUFJckUsVUFBVTtJQUN4QjtJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVM0RSxtQkFBbUJ0QyxZQUFZO0lBQ3BDLElBQUksQ0FBQ3pCLGVBQWV5QixlQUFlO1FBQy9CLE1BQU0sSUFBSXRDLFVBQVU7SUFDeEI7SUFDQSxPQUFPc0M7QUFDWDtBQUNBLFNBQVN1Qyx5QkFBeUJDLGdCQUFnQixFQUFFQyxnQkFBZ0I7SUFDaEUsSUFBSUEscUJBQXFCaEgsV0FBVztRQUNoQyxNQUFNLElBQUlpQyxVQUFVLENBQUMsOERBQThELEVBQUU4RSxpQkFBaUIsc0NBQXNDLENBQUM7SUFDako7QUFDSjtBQUNBLFNBQVNFLHFCQUFxQkYsZ0JBQWdCLEVBQUV4QyxZQUFZO0lBQ3hELElBQUlBLGlCQUFpQnZFLFdBQVc7UUFDNUIsTUFBTSxJQUFJaUMsVUFBVSxDQUFDLDBEQUEwRCxFQUFFOEUsaUJBQWlCLHNDQUFzQyxDQUFDO0lBQzdJO0FBQ0o7QUFDQSxlQUFlRyxxQkFBcUJwQixFQUFFLEVBQUVaLE1BQU0sRUFBRWlDLElBQUksRUFBRTNGLE9BQU8sRUFBRXdGLGdCQUFnQjtJQUMzRUcsS0FBSy9HLE1BQU0sQ0FBQztJQUNaK0csS0FBSy9HLE1BQU0sQ0FBQztJQUNaK0csS0FBSy9HLE1BQU0sQ0FBQztJQUNaLE9BQVE4RSxPQUFPa0MsMEJBQTBCO1FBQ3JDLEtBQUtwSDtRQUNMLEtBQUs7WUFBdUI7Z0JBQ3hCOEcseUJBQXlCLHVCQUF1QkU7Z0JBQ2hEeEYsUUFBUXRCLEdBQUcsQ0FBQyxpQkFBaUJtRSxrQkFBa0JhLE9BQU9vQixTQUFTLEVBQUVPLG1CQUFtQjNCLE9BQU9tQyxhQUFhO2dCQUN4RztZQUNKO1FBQ0EsS0FBSztZQUFzQjtnQkFDdkJQLHlCQUF5QixzQkFBc0JFO2dCQUMvQ0csS0FBS2pILEdBQUcsQ0FBQyxhQUFhZ0YsT0FBT29CLFNBQVM7Z0JBQ3RDYSxLQUFLakgsR0FBRyxDQUFDLGlCQUFpQjJHLG1CQUFtQjNCLE9BQU9tQyxhQUFhO2dCQUNqRTtZQUNKO1FBQ0EsS0FBSztZQUFtQjtnQkFDcEJKLHFCQUFxQixtQkFBbUIvQixPQUFPbUMsYUFBYTtnQkFDNUQsSUFBSUwscUJBQXFCaEgsV0FBVztvQkFDaEMsTUFBTSxJQUFJaUMsVUFBVTtnQkFDeEI7Z0JBQ0EsTUFBTSxFQUFFcEMsR0FBRyxFQUFFb0UsR0FBRyxFQUFFLEdBQUdELGFBQWFnRDtnQkFDbEMsSUFBSSxDQUFDaEcsYUFBYW5CLE1BQU07b0JBQ3BCLE1BQU0sSUFBSW9DLFVBQVU7Z0JBQ3hCO2dCQUNBa0YsS0FBS2pILEdBQUcsQ0FBQyxhQUFhZ0YsT0FBT29CLFNBQVM7Z0JBQ3RDYSxLQUFLakgsR0FBRyxDQUFDLHlCQUF5QjtnQkFDbENpSCxLQUFLakgsR0FBRyxDQUFDLG9CQUFvQixNQUFNc0csY0FBY1YsSUFBSVosUUFBUXJGLEtBQUtvRTtnQkFDbEU7WUFDSjtRQUNBLEtBQUs7WUFBUTtnQkFDVGdELHFCQUFxQixRQUFRL0IsT0FBT21DLGFBQWE7Z0JBQ2pEUCx5QkFBeUIsUUFBUUU7Z0JBQ2pDRyxLQUFLakgsR0FBRyxDQUFDLGFBQWFnRixPQUFPb0IsU0FBUztnQkFDdEM7WUFDSjtRQUNBO1lBQ0ksTUFBTSxJQUFJaEcsMEJBQTBCO0lBQzVDO0FBQ0o7QUFDQSxlQUFlbUcsSUFBSWEsTUFBTSxFQUFFQyxTQUFTLEVBQUUxSCxHQUFHO0lBQ3JDLElBQUksQ0FBQ0EsSUFBSTJILE1BQU0sQ0FBQ0MsUUFBUSxDQUFDLFNBQVM7UUFDOUIsTUFBTSxJQUFJeEYsVUFBVTtJQUN4QjtJQUNBLE1BQU10RSxRQUFRLENBQUMsRUFBRTBCLEtBQUszQixJQUFJZ0ssS0FBS0MsU0FBUyxDQUFDTCxVQUFVLENBQUMsRUFBRWpJLEtBQUszQixJQUFJZ0ssS0FBS0MsU0FBUyxDQUFDSixhQUFhLENBQUM7SUFDNUYsTUFBTUssWUFBWXZJLEtBQUssTUFBTWtFLE9BQU9PLE1BQU0sQ0FBQzBCLElBQUksQ0FBQ3FDLFlBQVloSSxNQUFNQSxLQUFLbkMsSUFBSUM7SUFDM0UsT0FBTyxDQUFDLEVBQUVBLE1BQU0sQ0FBQyxFQUFFaUssVUFBVSxDQUFDO0FBQ2xDO0FBQ08sZUFBZUUsbUJBQW1CaEMsRUFBRSxFQUFFWixNQUFNLEVBQUU2QyxVQUFVLEVBQUVDLFVBQVU7SUFDdkVyQixTQUFTYjtJQUNUYyxhQUFhMUI7SUFDYjZDLGFBQWEsSUFBSUUsZ0JBQWdCRjtJQUNqQyxNQUFNLEVBQUVsSSxHQUFHLEVBQUVvRSxHQUFHLEVBQUUsR0FBR0QsYUFBYWdFO0lBQ2xDLElBQUksQ0FBQ2hILGFBQWFuQixNQUFNO1FBQ3BCLE1BQU0sSUFBSW9DLFVBQVU7SUFDeEI7SUFDQThGLFdBQVc3SCxHQUFHLENBQUMsYUFBYWdGLE9BQU9vQixTQUFTO0lBQzVDLE1BQU1WLE1BQU1ILGNBQWNSLGFBQWFDO0lBQ3ZDLE1BQU1nRCxTQUFTO1FBQ1gsR0FBR0MsT0FBT0MsV0FBVyxDQUFDTCxXQUFXTSxPQUFPLEdBQUc7UUFDM0N0QyxLQUFLekM7UUFDTDBDLEtBQUtGLEdBQUd6QyxNQUFNO1FBQ2Q2QyxLQUFLTixNQUFNO1FBQ1hPLEtBQUtQO1FBQ0xRLEtBQUtSO1FBQ0xTLEtBQUtuQixPQUFPb0IsU0FBUztJQUN6QjtJQUNBLElBQUlnQztJQUNKLElBQUlQLFdBQVc5SCxHQUFHLENBQUMsZUFDZHFJLENBQUFBLFdBQVdQLFdBQVdRLE1BQU0sQ0FBQyxXQUFVLEtBQ3hDRCxTQUFTckosTUFBTSxHQUFHLEdBQUc7UUFDckJpSixPQUFPSSxRQUFRLEdBQUdBO0lBQ3RCO0lBQ0EsSUFBSVAsV0FBVzlILEdBQUcsQ0FBQyxXQUFXO1FBQzFCLE1BQU1FLFFBQVE0SCxXQUFXbkksR0FBRyxDQUFDO1FBQzdCLElBQUlPLFVBQVUsbUJBQW1CO1lBQzdCLE1BQU0sSUFBSWYsSUFBSTtRQUNsQjtRQUNBLElBQUk7WUFDQThJLE9BQU9BLE1BQU0sR0FBR1IsS0FBS2MsS0FBSyxDQUFDckk7UUFDL0IsRUFDQSxPQUFPaEIsT0FBTztZQUNWLE1BQU0sSUFBSUMsSUFBSSxrREFBa0Q7Z0JBQUVEO1lBQU07UUFDNUU7UUFDQSxJQUFJLENBQUN5QyxhQUFhc0csT0FBT0EsTUFBTSxHQUFHO1lBQzlCLE1BQU0sSUFBSTlJLElBQUk7UUFDbEI7SUFDSjtJQUNBLE9BQU9xSCxJQUFJO1FBQ1BDLEtBQUsxQixTQUFTbkY7UUFDZDRJLEtBQUs7UUFDTHhFO0lBQ0osR0FBR2lFLFFBQVFySTtBQUNmO0FBQ0EsZUFBZTZJLGFBQWFsSCxPQUFPLEVBQUVaLE9BQU8sRUFBRVUsR0FBRyxFQUFFcUgsR0FBRyxFQUFFeEwsU0FBUyxFQUFFeUwsV0FBVztJQUMxRSxNQUFNLEVBQUVaLFVBQVUsRUFBRWEsU0FBUyxFQUFFQyxRQUFRakksV0FBV2pCLEdBQUcsQ0FBQzBCLElBQUlHLE1BQU0sQ0FBQyxFQUFFLEdBQUdiO0lBQ3RFLElBQUksQ0FBQ0ksYUFBYWdILGFBQWE7UUFDM0IsTUFBTSxJQUFJL0YsVUFBVTtJQUN4QjtJQUNBLElBQUksQ0FBQ2YsWUFBWTJILFlBQVk7UUFDekIsTUFBTSxJQUFJNUcsVUFBVTtJQUN4QjtJQUNBLElBQUk2RyxVQUFVOUksYUFBYSxDQUFDOEMsZUFBZWdHLFFBQVE7UUFDL0MsTUFBTSxJQUFJN0csVUFBVTtJQUN4QjtJQUNBLElBQUksQ0FBQzRHLFVBQVVFLFdBQVcsRUFBRTtRQUN4QixNQUFNLElBQUk5RyxVQUFVO0lBQ3hCO0lBQ0EsTUFBTTJELE1BQU1ILGNBQWN0STtJQUMxQixNQUFNNkwsUUFBUSxNQUFNdkMsSUFBSTtRQUNwQkMsS0FBSzFCLFNBQVNnRDtRQUNkUyxLQUFLO1FBQ0xRLEtBQUssTUFBTUMsVUFBVUw7SUFDekIsR0FBRztRQUNDMUMsS0FBS1A7UUFDTEcsS0FBS3pDO1FBQ0xxRjtRQUNBRztRQUNBSyxLQUFLLENBQUMsRUFBRTdILElBQUlHLE1BQU0sQ0FBQyxFQUFFSCxJQUFJbUIsUUFBUSxDQUFDLENBQUM7UUFDbkMyRyxLQUFLUixjQUFjdkosS0FBSyxNQUFNa0UsT0FBT08sTUFBTSxDQUFDQyxNQUFNLENBQUMsV0FBV3JHLElBQUlrTCxpQkFBaUI1STtJQUN2RixHQUFHZ0k7SUFDSHhHLFFBQVF0QixHQUFHLENBQUMsUUFBUThJO0FBQ3hCO0FBQ0EsSUFBSUs7QUFDSixlQUFlSCxVQUFVckosR0FBRztJQUN4QndKLFlBQWFBLENBQUFBLFdBQVcsSUFBSUMsU0FBUTtJQUNwQyxJQUFJRCxTQUFTcEosR0FBRyxDQUFDSixNQUFNO1FBQ25CLE9BQU93SixTQUFTekosR0FBRyxDQUFDQztJQUN4QjtJQUNBLE1BQU0sRUFBRTBKLEdBQUcsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxHQUFHLEVBQUUsR0FBRyxNQUFNckcsT0FBT08sTUFBTSxDQUFDK0YsU0FBUyxDQUFDLE9BQU9oSztJQUN0RSxNQUFNb0osTUFBTTtRQUFFTTtRQUFLQztRQUFHQztRQUFHQztRQUFHQztRQUFHQztJQUFJO0lBQ25DUCxTQUFTbkosR0FBRyxDQUFDTCxLQUFLb0o7SUFDbEIsT0FBT0E7QUFDWDtBQUNPLGVBQWVhLDJCQUEyQmhFLEVBQUUsRUFBRVosTUFBTSxFQUFFNkMsVUFBVSxFQUFFbkgsT0FBTztJQUM1RStGLFNBQVNiO0lBQ1RjLGFBQWExQjtJQUNiLElBQUksT0FBT1ksR0FBR2lFLHFDQUFxQyxLQUFLLFVBQVU7UUFDOUQsTUFBTSxJQUFJOUgsVUFBVTtJQUN4QjtJQUNBLE1BQU1YLE1BQU0sSUFBSUMsSUFBSXVFLEdBQUdpRSxxQ0FBcUM7SUFDNUQsTUFBTTVDLE9BQU8sSUFBSWMsZ0JBQWdCRjtJQUNqQ1osS0FBS2pILEdBQUcsQ0FBQyxhQUFhZ0YsT0FBT29CLFNBQVM7SUFDdEMsTUFBTTlFLFVBQVVPLGVBQWVuQixTQUFTWTtJQUN4Q0EsUUFBUXRCLEdBQUcsQ0FBQyxVQUFVO0lBQ3RCLElBQUlVLFNBQVNvSixTQUFTaEssV0FBVztRQUM3QixNQUFNMEksYUFBYWxILFNBQVNaLFFBQVFvSixJQUFJLEVBQUUxSSxLQUFLLFFBQVEyRCxhQUFhQztJQUN4RTtJQUNBLE9BQU8rRSxxQkFBcUJuRSxJQUFJWixRQUFRLFFBQVE1RCxLQUFLNkYsTUFBTTNGLFNBQVNaO0FBQ3hFO0FBQ08sU0FBU3NKLGNBQWN2TSxLQUFLO0lBQy9CLE1BQU13QyxRQUFReEM7SUFDZCxJQUFJLE9BQU93QyxVQUFVLFlBQVkwQixNQUFNQyxPQUFPLENBQUMzQixVQUFVQSxVQUFVLE1BQU07UUFDckUsT0FBTztJQUNYO0lBQ0EsT0FBT0EsTUFBTWdLLEtBQUssS0FBS25LO0FBQzNCO0FBQ0EsU0FBU29LLFFBQVFqSyxLQUFLO0lBQ2xCLElBQUlBLE1BQU1sQixNQUFNLElBQUksS0FBS2tCLEtBQUssQ0FBQyxFQUFFLEtBQUssT0FBT0EsS0FBSyxDQUFDQSxNQUFNbEIsTUFBTSxHQUFHLEVBQUUsS0FBSyxLQUFLO1FBQzFFLE9BQU9rQixNQUFNa0ssS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUMzQjtJQUNBLE9BQU9sSztBQUNYO0FBQ0EsTUFBTW1LLGVBQWU7QUFDckIsTUFBTUMsaUJBQWlCO0FBQ3ZCLFNBQVNDLFFBQVFDLE1BQU0sRUFBRUMsTUFBTTtJQUMzQixNQUFNeE0sTUFBTXdNLE9BQU9DLEtBQUssQ0FBQ0wsY0FBY0QsS0FBSyxDQUFDO0lBQzdDLElBQUksQ0FBQ25NLElBQUllLE1BQU0sRUFBRTtRQUNiLE9BQU87WUFBRXdMLFFBQVFBLE9BQU85SSxXQUFXO1lBQUlvRyxZQUFZLENBQUM7UUFBRTtJQUMxRDtJQUNBN0osR0FBRyxDQUFDQSxJQUFJZSxNQUFNLEdBQUcsRUFBRSxHQUFHZixHQUFHLENBQUNBLElBQUllLE1BQU0sR0FBRyxFQUFFLENBQUNMLE9BQU8sQ0FBQyxNQUFNO0lBQ3hELE1BQU1tSixhQUFhLENBQUM7SUFDcEIsSUFBSyxJQUFJNUosSUFBSSxHQUFHQSxJQUFJRCxJQUFJZSxNQUFNLEVBQUVkLEtBQUssRUFBRztRQUNwQyxNQUFNeU0sTUFBTXpNO1FBQ1osSUFBSUQsR0FBRyxDQUFDME0sSUFBSSxDQUFDLEVBQUUsS0FBSyxLQUFLO1lBQ3JCLE1BQU8xTSxHQUFHLENBQUMwTSxJQUFJLENBQUNQLEtBQUssQ0FBQyxDQUFDLE9BQU8sT0FBTyxFQUFFbE0sSUFBSUQsSUFBSWUsTUFBTSxDQUFFO2dCQUNuRGYsR0FBRyxDQUFDME0sSUFBSSxJQUFJMU0sR0FBRyxDQUFDQyxFQUFFO1lBQ3RCO1FBQ0o7UUFDQSxNQUFNMEIsTUFBTTNCLEdBQUcsQ0FBQzBNLE1BQU0sRUFBRSxDQUFDaE0sT0FBTyxDQUFDLGdCQUFnQixJQUFJK0MsV0FBVztRQUNoRW9HLFVBQVUsQ0FBQ2xJLElBQUksR0FBR3VLLFFBQVFsTSxHQUFHLENBQUMwTSxJQUFJO0lBQ3RDO0lBQ0EsT0FBTztRQUNISCxRQUFRQSxPQUFPOUksV0FBVztRQUMxQm9HO0lBQ0o7QUFDSjtBQUNPLFNBQVM4QywrQkFBK0J4SixRQUFRO0lBQ25ELElBQUksQ0FBRUEsQ0FBQUEsb0JBQW9CNEIsUUFBTyxHQUFJO1FBQ2pDLE1BQU0sSUFBSWhCLFVBQVU7SUFDeEI7SUFDQSxJQUFJLENBQUNaLFNBQVNHLE9BQU8sQ0FBQ3ZCLEdBQUcsQ0FBQyxxQkFBcUI7UUFDM0MsT0FBT0Q7SUFDWDtJQUNBLE1BQU1zSCxTQUFTakcsU0FBU0csT0FBTyxDQUFDNUIsR0FBRyxDQUFDO0lBQ3BDLE1BQU1rTCxTQUFTLEVBQUU7SUFDakIsS0FBSyxNQUFNLEVBQUUsR0FBR0wsTUFBTSxFQUFFTSxLQUFLLEVBQUUsSUFBSXpELE9BQU8wRCxRQUFRLENBQUNULGdCQUFpQjtRQUNoRU8sT0FBT3pNLElBQUksQ0FBQztZQUFDb007WUFBUU07U0FBTTtJQUMvQjtJQUNBLElBQUksQ0FBQ0QsT0FBTzdMLE1BQU0sRUFBRTtRQUNoQixPQUFPZTtJQUNYO0lBQ0EsTUFBTWlMLGFBQWFILE9BQU9JLEdBQUcsQ0FBQyxDQUFDLENBQUNULFFBQVFVLFFBQVEsRUFBRWhOLEdBQUdpTjtRQUNqRCxNQUFNQyxPQUFPRCxNQUFNLENBQUNqTixJQUFJLEVBQUU7UUFDMUIsSUFBSTRKO1FBQ0osSUFBSXNELE1BQU07WUFDTnRELGFBQWFULE9BQU8rQyxLQUFLLENBQUNjLFNBQVNFLElBQUksQ0FBQyxFQUFFO1FBQzlDLE9BQ0s7WUFDRHRELGFBQWFULE9BQU8rQyxLQUFLLENBQUNjO1FBQzlCO1FBQ0EsT0FBT1gsUUFBUUMsUUFBUTFDO0lBQzNCO0lBQ0EsT0FBT2tEO0FBQ1g7QUFDTyxlQUFlSyxtQ0FBbUN4RixFQUFFLEVBQUVaLE1BQU0sRUFBRTdELFFBQVE7SUFDekVzRixTQUFTYjtJQUNUYyxhQUFhMUI7SUFDYixJQUFJLENBQUU3RCxDQUFBQSxvQkFBb0I0QixRQUFPLEdBQUk7UUFDakMsTUFBTSxJQUFJaEIsVUFBVTtJQUN4QjtJQUNBLElBQUlaLFNBQVM2QixNQUFNLEtBQUssS0FBSztRQUN6QixJQUFJcUk7UUFDSixJQUFLQSxNQUFNLE1BQU1DLHFCQUFxQm5LLFdBQVk7WUFDOUMsT0FBT2tLO1FBQ1g7UUFDQSxNQUFNLElBQUluTSxJQUFJO0lBQ2xCO0lBQ0ErRCx1QkFBdUI5QjtJQUN2QixJQUFJK0I7SUFDSixJQUFJO1FBQ0FBLE9BQU8sTUFBTS9CLFNBQVMrQixJQUFJO0lBQzlCLEVBQ0EsT0FBT2pFLE9BQU87UUFDVixNQUFNLElBQUlDLElBQUksMkNBQTJDO1lBQUVEO1FBQU07SUFDckU7SUFDQSxJQUFJLENBQUN5QyxhQUFhd0IsT0FBTztRQUNyQixNQUFNLElBQUloRSxJQUFJO0lBQ2xCO0lBQ0EsSUFBSSxDQUFDMEQsZUFBZU0sS0FBS3FJLFdBQVcsR0FBRztRQUNuQyxNQUFNLElBQUlyTSxJQUFJO0lBQ2xCO0lBQ0EsSUFBSSxPQUFPZ0UsS0FBS3NJLFVBQVUsS0FBSyxZQUFZdEksS0FBS3NJLFVBQVUsSUFBSSxHQUFHO1FBQzdELE1BQU0sSUFBSXRNLElBQUk7SUFDbEI7SUFDQSxPQUFPZ0U7QUFDWDtBQUNPLGVBQWV1SSx5QkFBeUIvQyxXQUFXLEVBQUVqRyxNQUFNLEVBQUVyQixHQUFHLEVBQUVFLE9BQU8sRUFBRTJGLElBQUksRUFBRXZHLE9BQU87SUFDM0YsSUFBSSxDQUFDa0MsZUFBZThGLGNBQWM7UUFDOUIsTUFBTSxJQUFJM0csVUFBVTtJQUN4QjtJQUNBLElBQUksQ0FBRVgsQ0FBQUEsZUFBZUMsR0FBRSxHQUFJO1FBQ3ZCLE1BQU0sSUFBSVUsVUFBVTtJQUN4QjtJQUNBVCxVQUFVTyxlQUFlUDtJQUN6QixJQUFJWixTQUFTb0osU0FBU2hLLFdBQVc7UUFDN0J3QixRQUFRdEIsR0FBRyxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRTBJLFlBQVksQ0FBQztJQUN4RCxPQUNLO1FBQ0QsTUFBTUYsYUFBYWxILFNBQVNaLFFBQVFvSixJQUFJLEVBQUUxSSxLQUFLLE9BQU8yRCxhQUFhO1lBQUUsQ0FBQzlILFVBQVUsRUFBRXlELFNBQVN6RDtRQUFVLElBQUl5TDtRQUN6R3BILFFBQVF0QixHQUFHLENBQUMsaUJBQWlCLENBQUMsS0FBSyxFQUFFMEksWUFBWSxDQUFDO0lBQ3REO0lBQ0EsT0FBT2xHLE1BQU1wQixJQUFJaUIsSUFBSSxFQUFFO1FBQ25CNEU7UUFDQTNGO1FBQ0FtQjtRQUNBQyxVQUFVO1FBQ1ZWLFFBQVF0QixTQUFTc0IsU0FBU0EsT0FBT3RCLFFBQVFzQixNQUFNLElBQUk7SUFDdkQsR0FBR1csSUFBSSxDQUFDekI7QUFDWjtBQUNPLGVBQWV3SyxnQkFBZ0I5RixFQUFFLEVBQUVaLE1BQU0sRUFBRTBELFdBQVcsRUFBRWhJLE9BQU87SUFDbEUrRixTQUFTYjtJQUNUYyxhQUFhMUI7SUFDYixJQUFJLE9BQU9ZLEdBQUcrRixpQkFBaUIsS0FBSyxVQUFVO1FBQzFDLE1BQU0sSUFBSTVKLFVBQVU7SUFDeEI7SUFDQSxNQUFNWCxNQUFNLElBQUlDLElBQUl1RSxHQUFHK0YsaUJBQWlCO0lBQ3hDLE1BQU1ySyxVQUFVTyxlQUFlbkIsU0FBU1k7SUFDeEMsSUFBSTBELE9BQU80Ryw0QkFBNEIsRUFBRTtRQUNyQ3RLLFFBQVF0QixHQUFHLENBQUMsVUFBVTtJQUMxQixPQUNLO1FBQ0RzQixRQUFRdEIsR0FBRyxDQUFDLFVBQVU7UUFDdEJzQixRQUFRdUssTUFBTSxDQUFDLFVBQVU7SUFDN0I7SUFDQSxPQUFPSix5QkFBeUIvQyxhQUFhLE9BQU90SCxLQUFLRSxTQUFTLE1BQU07UUFDcEUsR0FBR1osT0FBTztRQUNWekQsV0FBVzhILGFBQWFDO0lBQzVCO0FBQ0o7QUFDQSxJQUFJOEc7QUFDSixlQUFlQyxpQ0FBaUNuRyxFQUFFLEVBQUVsRixPQUFPLEVBQUUwRyxNQUFNO0lBQy9ELE1BQU0sRUFBRVosR0FBRyxFQUFFekMsR0FBRyxFQUFFLEdBQUdxRDtJQUNyQjRFLHFCQUFxQnhGO0lBQ3JCLElBQUl5RjtJQUNKLElBQUlDO0lBQ0pKLGFBQWNBLENBQUFBLFlBQVksSUFBSTFDLFNBQVE7SUFDdEMsSUFBSTBDLFVBQVUvTCxHQUFHLENBQUM2RixLQUFLOztRQUVsQixHQUFFcUcsSUFBSSxFQUFFQyxHQUFHLEVBQUUsR0FBR0osVUFBVXBNLEdBQUcsQ0FBQ2tHLEdBQUU7UUFDakMsSUFBSXNHLE9BQU8sS0FBSztZQUNaSixVQUFVNUwsTUFBTSxDQUFDMEY7WUFDakIsT0FBT21HLGlDQUFpQ25HLElBQUlsRixTQUFTMEc7UUFDekQ7SUFDSixPQUNLO1FBQ0Q2RSxPQUFPLE1BQU1FLFlBQVl2RyxJQUFJbEYsU0FBU2lDLElBQUksQ0FBQ3lKO1FBQzNDRixNQUFNO1FBQ05KLFVBQVU5TCxHQUFHLENBQUM0RixJQUFJO1lBQ2RxRztZQUNBaEcsS0FBS1Y7WUFDTCxJQUFJMkcsT0FBTTtnQkFDTixPQUFPM0csY0FBYyxJQUFJLENBQUNVLEdBQUc7WUFDakM7UUFDSjtJQUNKO0lBQ0EsSUFBSW9EO0lBQ0osT0FBUTdDLElBQUkyRCxLQUFLLENBQUMsR0FBRztRQUNqQixLQUFLO1FBQ0wsS0FBSztZQUNEZCxNQUFNO1lBQ047UUFDSixLQUFLO1lBQ0RBLE1BQU07WUFDTjtRQUNKLEtBQUs7WUFDREEsTUFBTTtZQUNOO1FBQ0o7WUFDSSxNQUFNLElBQUlqSjtJQUNsQjtJQUNBLE1BQU1pTSxhQUFhSixLQUFLSyxJQUFJLENBQUNDLE1BQU0sQ0FBQyxDQUFDeEQ7UUFDakMsSUFBSUEsSUFBSU0sR0FBRyxLQUFLQSxLQUFLO1lBQ2pCLE9BQU87UUFDWDtRQUNBLElBQUl0RixRQUFRakUsYUFBYWlFLFFBQVFnRixJQUFJaEYsR0FBRyxFQUFFO1lBQ3RDLE9BQU87UUFDWDtRQUNBLElBQUlnRixJQUFJdkMsR0FBRyxLQUFLMUcsYUFBYTBHLFFBQVF1QyxJQUFJdkMsR0FBRyxFQUFFO1lBQzFDLE9BQU87UUFDWDtRQUNBLElBQUl1QyxJQUFJeUQsR0FBRyxLQUFLMU0sYUFBYWlKLElBQUl5RCxHQUFHLEtBQUssT0FBTztZQUM1QyxPQUFPO1FBQ1g7UUFDQSxJQUFJekQsSUFBSTBELE9BQU8sRUFBRWxGLFNBQVMsY0FBYyxPQUFPO1lBQzNDLE9BQU87UUFDWDtRQUNBLE9BQVE7WUFDSixLQUFLZixRQUFRLFdBQVd1QyxJQUFJVyxHQUFHLEtBQUs7WUFDcEMsS0FBS2xELFFBQVEsV0FBV3VDLElBQUlXLEdBQUcsS0FBSztZQUNwQyxLQUFLbEQsUUFBUSxXQUFXdUMsSUFBSVcsR0FBRyxLQUFLO1lBQ3BDLEtBQUtsRCxRQUFRLFdBQVcsQ0FBRXVDLENBQUFBLElBQUlXLEdBQUcsS0FBSyxhQUFhWCxJQUFJVyxHQUFHLEtBQUssT0FBTTtnQkFDakUsT0FBTztRQUNmO1FBQ0EsT0FBTztJQUNYO0lBQ0EsTUFBTSxFQUFFLEdBQUdYLEdBQUcsRUFBRWhLLE1BQU0sRUFBRSxHQUFHc047SUFDM0IsSUFBSSxDQUFDdE4sUUFBUTtRQUNULElBQUltTixPQUFPLElBQUk7WUFDWEosVUFBVTVMLE1BQU0sQ0FBQzBGO1lBQ2pCLE9BQU9tRyxpQ0FBaUNuRyxJQUFJbEYsU0FBUzBHO1FBQ3pEO1FBQ0EsTUFBTSxJQUFJbEksSUFBSTtJQUNsQixPQUNLLElBQUlILFdBQVcsR0FBRztRQUNuQixNQUFNLElBQUlHLElBQUk7SUFDbEI7SUFDQSxNQUFNUyxNQUFNLE1BQU0rTSxVQUFVbEcsS0FBS3VDO0lBQ2pDLElBQUlwSixJQUFJb0IsSUFBSSxLQUFLLFVBQVU7UUFDdkIsTUFBTSxJQUFJN0IsSUFBSTtJQUNsQjtJQUNBLE9BQU9TO0FBQ1g7QUFDTyxNQUFNZ04sbUJBQW1CelAsU0FBUztBQUN6QyxTQUFTMFAsZUFBZXpMLFFBQVE7SUFDNUIsT0FBT0EsU0FBU0csT0FBTyxDQUFDNUIsR0FBRyxDQUFDLGlCQUFpQitLLE1BQU0sSUFBSSxDQUFDLEVBQUU7QUFDOUQ7QUFDTyxlQUFlb0Msd0JBQXdCakgsRUFBRSxFQUFFWixNQUFNLEVBQUU4SCxlQUFlLEVBQUUzTCxRQUFRO0lBQy9Fc0YsU0FBU2I7SUFDVGMsYUFBYTFCO0lBQ2IsSUFBSSxDQUFFN0QsQ0FBQUEsb0JBQW9CNEIsUUFBTyxHQUFJO1FBQ2pDLE1BQU0sSUFBSWhCLFVBQVU7SUFDeEI7SUFDQSxJQUFJWixTQUFTNkIsTUFBTSxLQUFLLEtBQUs7UUFDekIsTUFBTSxJQUFJOUQsSUFBSTtJQUNsQjtJQUNBLElBQUlnRTtJQUNKLElBQUkwSixlQUFlekwsY0FBYyxtQkFBbUI7UUFDaEQ4Qix1QkFBdUI5QjtRQUN2QixNQUFNLEVBQUU2RyxNQUFNLEVBQUUsR0FBRyxNQUFNK0UsWUFBWSxNQUFNNUwsU0FBUzZMLElBQUksSUFBSUMsc0JBQXNCQyxJQUFJLENBQUNwTixXQUFXa0YsT0FBTzRHLDRCQUE0QixFQUFFaEcsR0FBR3VILHFDQUFxQyxHQUFHQyxrQkFBa0JySSxhQUFhQyxTQUFTRyxrQkFBa0JILFNBQ3ZPckMsSUFBSSxDQUFDMEsseUJBQXlCSCxJQUFJLENBQUNwTixXQUFXa0YsT0FBT29CLFNBQVMsR0FDOUR6RCxJQUFJLENBQUMySyx1QkFBdUJKLElBQUksQ0FBQ3BOLFdBQVc4RixHQUFHekMsTUFBTTtRQUMxREQsT0FBTzhFO0lBQ1gsT0FDSztRQUNELElBQUloRCxPQUFPNEcsNEJBQTRCLEVBQUU7WUFDckMsTUFBTSxJQUFJMU0sSUFBSTtRQUNsQjtRQUNBK0QsdUJBQXVCOUI7UUFDdkIsSUFBSTtZQUNBK0IsT0FBTyxNQUFNL0IsU0FBUytCLElBQUk7UUFDOUIsRUFDQSxPQUFPakUsT0FBTztZQUNWLE1BQU0sSUFBSUMsSUFBSSwyQ0FBMkM7Z0JBQUVEO1lBQU07UUFDckU7SUFDSjtJQUNBLElBQUksQ0FBQ3lDLGFBQWF3QixPQUFPO1FBQ3JCLE1BQU0sSUFBSWhFLElBQUk7SUFDbEI7SUFDQSxJQUFJLENBQUMwRCxlQUFlTSxLQUFLbUQsR0FBRyxHQUFHO1FBQzNCLE1BQU0sSUFBSW5ILElBQUk7SUFDbEI7SUFDQSxPQUFRNE47UUFDSixLQUFLSDtZQUNEO1FBQ0o7WUFDSSxJQUFJLENBQUMvSixlQUFla0ssa0JBQWtCO2dCQUNsQyxNQUFNLElBQUk1TixJQUFJO1lBQ2xCO1lBQ0EsSUFBSWdFLEtBQUttRCxHQUFHLEtBQUt5RyxpQkFBaUI7Z0JBQzlCLE1BQU0sSUFBSTVOLElBQUk7WUFDbEI7SUFDUjtJQUNBLE9BQU9nRTtBQUNYO0FBQ0EsZUFBZTZHLHFCQUFxQm5FLEVBQUUsRUFBRVosTUFBTSxFQUFFdkMsTUFBTSxFQUFFckIsR0FBRyxFQUFFNkYsSUFBSSxFQUFFM0YsT0FBTyxFQUFFWixPQUFPO0lBQy9FLE1BQU1zRyxxQkFBcUJwQixJQUFJWixRQUFRaUMsTUFBTTNGLFNBQVNaLFNBQVNvRztJQUMvRHhGLFFBQVF0QixHQUFHLENBQUMsZ0JBQWdCO0lBQzVCLE9BQU93QyxNQUFNcEIsSUFBSWlCLElBQUksRUFBRTtRQUNuQjRFO1FBQ0EzRjtRQUNBbUI7UUFDQUMsVUFBVTtRQUNWVixRQUFRdEIsU0FBU3NCLFNBQVNBLE9BQU90QixRQUFRc0IsTUFBTSxJQUFJO0lBQ3ZELEdBQUdXLElBQUksQ0FBQ3pCO0FBQ1o7QUFDQSxlQUFlcU0scUJBQXFCM0gsRUFBRSxFQUFFWixNQUFNLEVBQUV3SSxTQUFTLEVBQUUzRixVQUFVLEVBQUVuSCxPQUFPO0lBQzFFLElBQUksT0FBT2tGLEdBQUdHLGNBQWMsS0FBSyxVQUFVO1FBQ3ZDLE1BQU0sSUFBSWhFLFVBQVU7SUFDeEI7SUFDQSxNQUFNWCxNQUFNLElBQUlDLElBQUl1RSxHQUFHRyxjQUFjO0lBQ3JDOEIsV0FBVzdILEdBQUcsQ0FBQyxjQUFjd047SUFDN0IsTUFBTWxNLFVBQVVPLGVBQWVuQixTQUFTWTtJQUN4Q0EsUUFBUXRCLEdBQUcsQ0FBQyxVQUFVO0lBQ3RCLElBQUlVLFNBQVNvSixTQUFTaEssV0FBVztRQUM3QixNQUFNMEksYUFBYWxILFNBQVNaLFFBQVFvSixJQUFJLEVBQUUxSSxLQUFLLFFBQVEyRCxhQUFhQztJQUN4RTtJQUNBLE9BQU8rRSxxQkFBcUJuRSxJQUFJWixRQUFRLFFBQVE1RCxLQUFLeUcsWUFBWXZHLFNBQVNaO0FBQzlFO0FBQ08sZUFBZStNLHlCQUF5QjdILEVBQUUsRUFBRVosTUFBTSxFQUFFMEksWUFBWSxFQUFFaE4sT0FBTztJQUM1RStGLFNBQVNiO0lBQ1RjLGFBQWExQjtJQUNiLElBQUksQ0FBQ3BDLGVBQWU4SyxlQUFlO1FBQy9CLE1BQU0sSUFBSTNMLFVBQVU7SUFDeEI7SUFDQSxNQUFNOEYsYUFBYSxJQUFJRSxnQkFBZ0JySCxTQUFTaU47SUFDaEQ5RixXQUFXN0gsR0FBRyxDQUFDLGlCQUFpQjBOO0lBQ2hDLE9BQU9ILHFCQUFxQjNILElBQUlaLFFBQVEsaUJBQWlCNkMsWUFBWW5IO0FBQ3pFO0FBQ0EsTUFBTWtOLGdCQUFnQixJQUFJeEU7QUFDbkIsU0FBU3lFLDBCQUEwQkMsR0FBRztJQUN6QyxJQUFJLENBQUNBLElBQUlDLFFBQVEsRUFBRTtRQUNmLE9BQU9qTztJQUNYO0lBQ0EsTUFBTWtJLFNBQVM0RixjQUFjbE8sR0FBRyxDQUFDb087SUFDakMsSUFBSSxDQUFDOUYsUUFBUTtRQUNULE1BQU0sSUFBSWpHLFVBQVU7SUFDeEI7SUFDQSxPQUFPaUc7QUFDWDtBQUNBLGVBQWVnRyxrQ0FBa0NwSSxFQUFFLEVBQUVaLE1BQU0sRUFBRTdELFFBQVEsRUFBRThNLGdCQUFnQixLQUFLLEVBQUVDLHFCQUFxQixLQUFLO0lBQ3BIekgsU0FBU2I7SUFDVGMsYUFBYTFCO0lBQ2IsSUFBSSxDQUFFN0QsQ0FBQUEsb0JBQW9CNEIsUUFBTyxHQUFJO1FBQ2pDLE1BQU0sSUFBSWhCLFVBQVU7SUFDeEI7SUFDQSxJQUFJWixTQUFTNkIsTUFBTSxLQUFLLEtBQUs7UUFDekIsSUFBSXFJO1FBQ0osSUFBS0EsTUFBTSxNQUFNQyxxQkFBcUJuSyxXQUFZO1lBQzlDLE9BQU9rSztRQUNYO1FBQ0EsTUFBTSxJQUFJbk0sSUFBSTtJQUNsQjtJQUNBK0QsdUJBQXVCOUI7SUFDdkIsSUFBSStCO0lBQ0osSUFBSTtRQUNBQSxPQUFPLE1BQU0vQixTQUFTK0IsSUFBSTtJQUM5QixFQUNBLE9BQU9qRSxPQUFPO1FBQ1YsTUFBTSxJQUFJQyxJQUFJLDJDQUEyQztZQUFFRDtRQUFNO0lBQ3JFO0lBQ0EsSUFBSSxDQUFDeUMsYUFBYXdCLE9BQU87UUFDckIsTUFBTSxJQUFJaEUsSUFBSTtJQUNsQjtJQUNBLElBQUksQ0FBQzBELGVBQWVNLEtBQUtpTCxZQUFZLEdBQUc7UUFDcEMsTUFBTSxJQUFJalAsSUFBSTtJQUNsQjtJQUNBLElBQUksQ0FBQzBELGVBQWVNLEtBQUtrTCxVQUFVLEdBQUc7UUFDbEMsTUFBTSxJQUFJbFAsSUFBSTtJQUNsQjtJQUNBZ0UsS0FBS2tMLFVBQVUsR0FBR2xMLEtBQUtrTCxVQUFVLENBQUMzTSxXQUFXO0lBQzdDLElBQUl5QixLQUFLa0wsVUFBVSxLQUFLLFVBQVVsTCxLQUFLa0wsVUFBVSxLQUFLLFVBQVU7UUFDNUQsTUFBTSxJQUFJaE8sMEJBQTBCO0lBQ3hDO0lBQ0EsSUFBSThDLEtBQUtzSSxVQUFVLEtBQUsxTCxhQUNuQixRQUFPb0QsS0FBS3NJLFVBQVUsS0FBSyxZQUFZdEksS0FBS3NJLFVBQVUsSUFBSSxJQUFJO1FBQy9ELE1BQU0sSUFBSXRNLElBQUk7SUFDbEI7SUFDQSxJQUFJLENBQUNnUCxzQkFDRGhMLEtBQUttTCxhQUFhLEtBQUt2TyxhQUN2QixDQUFDOEMsZUFBZU0sS0FBS21MLGFBQWEsR0FBRztRQUNyQyxNQUFNLElBQUluUCxJQUFJO0lBQ2xCO0lBQ0EsSUFBSWdFLEtBQUtvTCxLQUFLLEtBQUt4TyxhQUFhLE9BQU9vRCxLQUFLb0wsS0FBSyxLQUFLLFVBQVU7UUFDNUQsTUFBTSxJQUFJcFAsSUFBSTtJQUNsQjtJQUNBLElBQUksQ0FBQytPLGVBQWU7UUFDaEIsSUFBSS9LLEtBQUs2SyxRQUFRLEtBQUtqTyxhQUFhLENBQUM4QyxlQUFlTSxLQUFLNkssUUFBUSxHQUFHO1lBQy9ELE1BQU0sSUFBSTdPLElBQUk7UUFDbEI7UUFDQSxJQUFJZ0UsS0FBSzZLLFFBQVEsRUFBRTtZQUNmLE1BQU0sRUFBRS9GLE1BQU0sRUFBRSxHQUFHLE1BQU0rRSxZQUFZN0osS0FBSzZLLFFBQVEsRUFBRWQsc0JBQXNCQyxJQUFJLENBQUNwTixXQUFXa0YsT0FBT3VKLDRCQUE0QixFQUFFM0ksR0FBRzRJLHFDQUFxQyxHQUFHcEIsa0JBQWtCckksYUFBYUMsU0FBU0csa0JBQWtCSCxTQUMvTnJDLElBQUksQ0FBQzhMLGlCQUFpQnZCLElBQUksQ0FBQ3BOLFdBQVc7Z0JBQUM7Z0JBQU87Z0JBQU87Z0JBQU87Z0JBQU87YUFBTSxHQUN6RTZDLElBQUksQ0FBQytMLGVBQWV4QixJQUFJLENBQUNwTixXQUFXOEYsR0FBR3pDLE1BQU0sR0FDN0NSLElBQUksQ0FBQ2dNLGlCQUFpQnpCLElBQUksQ0FBQ3BOLFdBQVdrRixPQUFPb0IsU0FBUztZQUMzRCxJQUFJekUsTUFBTUMsT0FBTyxDQUFDb0csT0FBT2xDLEdBQUcsS0FBS2tDLE9BQU9sQyxHQUFHLENBQUMvRyxNQUFNLEtBQUssS0FBS2lKLE9BQU80RyxHQUFHLEtBQUs1SixPQUFPb0IsU0FBUyxFQUFFO2dCQUN6RixNQUFNLElBQUlsSCxJQUFJO1lBQ2xCO1lBQ0EsSUFBSThGLE9BQU82SixpQkFBaUIsSUFBSSxPQUFPN0csT0FBTzhHLFNBQVMsS0FBSyxVQUFVO2dCQUNsRSxNQUFNLElBQUk1UCxJQUFJO1lBQ2xCO1lBQ0EwTyxjQUFjNU4sR0FBRyxDQUFDa0QsTUFBTThFO1FBQzVCO0lBQ0o7SUFDQSxPQUFPOUU7QUFDWDtBQUNPLGVBQWU2TCw0QkFBNEJuSixFQUFFLEVBQUVaLE1BQU0sRUFBRTdELFFBQVE7SUFDbEUsT0FBTzZNLGtDQUFrQ3BJLElBQUlaLFFBQVE3RDtBQUN6RDtBQUNBLFNBQVNrTSx5QkFBeUIyQixRQUFRLEVBQUVwRSxNQUFNO0lBQzlDLElBQUlBLE9BQU81QyxNQUFNLENBQUNsQyxHQUFHLEtBQUtoRyxXQUFXO1FBQ2pDLE9BQU82TyxpQkFBaUJLLFVBQVVwRTtJQUN0QztJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTK0QsaUJBQWlCSyxRQUFRLEVBQUVwRSxNQUFNO0lBQ3RDLElBQUlqSixNQUFNQyxPQUFPLENBQUNnSixPQUFPNUMsTUFBTSxDQUFDbEMsR0FBRyxHQUFHO1FBQ2xDLElBQUksQ0FBQzhFLE9BQU81QyxNQUFNLENBQUNsQyxHQUFHLENBQUN5QixRQUFRLENBQUN5SCxXQUFXO1lBQ3ZDLE1BQU0sSUFBSTlQLElBQUk7UUFDbEI7SUFDSixPQUNLLElBQUkwTCxPQUFPNUMsTUFBTSxDQUFDbEMsR0FBRyxLQUFLa0osVUFBVTtRQUNyQyxNQUFNLElBQUk5UCxJQUFJO0lBQ2xCO0lBQ0EsT0FBTzBMO0FBQ1g7QUFDQSxTQUFTMEMsdUJBQXVCMEIsUUFBUSxFQUFFcEUsTUFBTTtJQUM1QyxJQUFJQSxPQUFPNUMsTUFBTSxDQUFDN0IsR0FBRyxLQUFLckcsV0FBVztRQUNqQyxPQUFPNE8sZUFBZU0sVUFBVXBFO0lBQ3BDO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVM4RCxlQUFlTSxRQUFRLEVBQUVwRSxNQUFNO0lBQ3BDLElBQUlBLE9BQU81QyxNQUFNLENBQUM3QixHQUFHLEtBQUs2SSxVQUFVO1FBQ2hDLE1BQU0sSUFBSTlQLElBQUk7SUFDbEI7SUFDQSxPQUFPMEw7QUFDWDtBQUNBLE1BQU1xRSxVQUFVLElBQUlDO0FBQ3BCLFNBQVNDLE1BQU1DLFlBQVk7SUFDdkJILFFBQVFJLEdBQUcsQ0FBQ0Q7SUFDWixPQUFPQTtBQUNYO0FBQ08sZUFBZUUsOEJBQThCMUosRUFBRSxFQUFFWixNQUFNLEVBQUV1SyxrQkFBa0IsRUFBRUMsV0FBVyxFQUFFN0wsWUFBWSxFQUFFakQsT0FBTztJQUNsSCtGLFNBQVNiO0lBQ1RjLGFBQWExQjtJQUNiLElBQUksQ0FBQ2lLLFFBQVFsUCxHQUFHLENBQUN3UCxxQkFBcUI7UUFDbEMsTUFBTSxJQUFJeE4sVUFBVTtJQUN4QjtJQUNBLElBQUksQ0FBQ2EsZUFBZTRNLGNBQWM7UUFDOUIsTUFBTSxJQUFJek4sVUFBVTtJQUN4QjtJQUNBLElBQUksQ0FBQ2EsZUFBZWUsZUFBZTtRQUMvQixNQUFNLElBQUk1QixVQUFVO0lBQ3hCO0lBQ0EsTUFBTTBOLE9BQU9DLHNCQUFzQkgsb0JBQW9CO0lBQ3ZELElBQUksQ0FBQ0UsTUFBTTtRQUNQLE1BQU0sSUFBSXZRLElBQUk7SUFDbEI7SUFDQSxNQUFNMkksYUFBYSxJQUFJRSxnQkFBZ0JySCxTQUFTaU47SUFDaEQ5RixXQUFXN0gsR0FBRyxDQUFDLGdCQUFnQndQO0lBQy9CM0gsV0FBVzdILEdBQUcsQ0FBQyxpQkFBaUIyRDtJQUNoQ2tFLFdBQVc3SCxHQUFHLENBQUMsUUFBUXlQO0lBQ3ZCLE9BQU9sQyxxQkFBcUIzSCxJQUFJWixRQUFRLHNCQUFzQjZDLFlBQVluSDtBQUM5RTtBQUNBLE1BQU1pUCxhQUFhO0lBQ2Y3SixLQUFLO0lBQ0xFLEtBQUs7SUFDTEMsS0FBSztJQUNMRSxLQUFLO0lBQ0xFLEtBQUs7QUFDVDtBQUNBLFNBQVNvSSxpQkFBaUJtQixRQUFRLEVBQUVoRixNQUFNO0lBQ3RDLEtBQUssTUFBTWlGLFNBQVNELFNBQVU7UUFDMUIsSUFBSWhGLE9BQU81QyxNQUFNLENBQUM2SCxNQUFNLEtBQUsvUCxXQUFXO1lBQ3BDLE1BQU0sSUFBSVosSUFBSSxDQUFDLEtBQUssRUFBRTJRLE1BQU0sR0FBRyxFQUFFRixVQUFVLENBQUNFLE1BQU0sQ0FBQyxlQUFlLENBQUM7UUFDdkU7SUFDSjtJQUNBLE9BQU9qRjtBQUNYO0FBQ08sTUFBTWtGLGdCQUFnQjVTLFNBQVM7QUFDL0IsTUFBTTZTLG9CQUFvQjdTLFNBQVM7QUFDbkMsZUFBZThTLHVDQUF1Q3BLLEVBQUUsRUFBRVosTUFBTSxFQUFFN0QsUUFBUSxFQUFFOE8sYUFBYSxFQUFFQyxNQUFNO0lBQ3BHLE1BQU10RixTQUFTLE1BQU1vRCxrQ0FBa0NwSSxJQUFJWixRQUFRN0Q7SUFDbkUsSUFBSTZJLGNBQWNZLFNBQVM7UUFDdkIsT0FBT0E7SUFDWDtJQUNBLElBQUksQ0FBQ2hJLGVBQWVnSSxPQUFPbUQsUUFBUSxHQUFHO1FBQ2xDLE1BQU0sSUFBSTdPLElBQUk7SUFDbEI7SUFDQWdSLFVBQVdBLENBQUFBLFNBQVNsTCxPQUFPbUwsZUFBZSxJQUFJSixpQkFBZ0I7SUFDOUQsTUFBTS9ILFNBQVM2RiwwQkFBMEJqRDtJQUN6QyxJQUFJLENBQUM1RixPQUFPNkosaUJBQWlCLElBQUlxQixXQUFXSCxpQkFBZ0IsS0FDeEQvSCxPQUFPOEcsU0FBUyxLQUFLaFAsV0FBVztRQUNoQyxNQUFNLElBQUlaLElBQUk7SUFDbEI7SUFDQSxJQUFJZ1IsV0FBV0gsbUJBQW1CO1FBQzlCLElBQUksT0FBT0csV0FBVyxZQUFZQSxTQUFTLEdBQUc7WUFDMUMsTUFBTSxJQUFJbk8sVUFBVTtRQUN4QjtRQUNBLE1BQU0yRCxNQUFNSCxjQUFjUixhQUFhQztRQUN2QyxNQUFNSSxZQUFZRCxrQkFBa0JIO1FBQ3BDLElBQUlnRCxPQUFPOEcsU0FBUyxHQUFHb0IsU0FBU3hLLE1BQU1OLFdBQVc7WUFDN0MsTUFBTSxJQUFJbEcsSUFBSTtRQUNsQjtJQUNKO0lBQ0EsT0FBUStRO1FBQ0osS0FBS25RO1FBQ0wsS0FBS2dRO1lBQ0QsSUFBSTlILE9BQU9ZLEtBQUssS0FBSzlJLFdBQVc7Z0JBQzVCLE1BQU0sSUFBSVosSUFBSTtZQUNsQjtZQUNBO1FBQ0o7WUFDSSxJQUFJLENBQUMwRCxlQUFlcU4sZ0JBQWdCO2dCQUNoQyxNQUFNLElBQUlsTyxVQUFVO1lBQ3hCO1lBQ0EsSUFBSWlHLE9BQU9ZLEtBQUssS0FBSzlJLFdBQVc7Z0JBQzVCLE1BQU0sSUFBSVosSUFBSTtZQUNsQjtZQUNBLElBQUk4SSxPQUFPWSxLQUFLLEtBQUtxSCxlQUFlO2dCQUNoQyxNQUFNLElBQUkvUSxJQUFJO1lBQ2xCO0lBQ1I7SUFDQSxPQUFPMEw7QUFDWDtBQUNPLGVBQWV3Rix1Q0FBdUN4SyxFQUFFLEVBQUVaLE1BQU0sRUFBRTdELFFBQVE7SUFDN0UsTUFBTXlKLFNBQVMsTUFBTW9ELGtDQUFrQ3BJLElBQUlaLFFBQVE3RCxVQUFVO0lBQzdFLElBQUk2SSxjQUFjWSxTQUFTO1FBQ3ZCLE9BQU9BO0lBQ1g7SUFDQSxJQUFJQSxPQUFPbUQsUUFBUSxLQUFLak8sV0FBVztRQUMvQixJQUFJLE9BQU84SyxPQUFPbUQsUUFBUSxLQUFLLFlBQVluRCxPQUFPbUQsUUFBUSxDQUFDaFAsTUFBTSxFQUFFO1lBQy9ELE1BQU0sSUFBSUcsSUFBSTtRQUNsQjtRQUNBLE9BQU8wTCxPQUFPbUQsUUFBUTtJQUMxQjtJQUNBLE9BQU9uRDtBQUNYO0FBQ0EsU0FBU3lGLGFBQWFyQixRQUFRLEVBQUVwRSxNQUFNO0lBQ2xDLElBQUksT0FBT0EsT0FBT3hELE1BQU0sQ0FBQ21CLEdBQUcsS0FBSyxZQUFZL0csYUFBYW9KLE9BQU94RCxNQUFNLENBQUNtQixHQUFHLE1BQU15RyxVQUFVO1FBQ3ZGLE1BQU0sSUFBSTlQLElBQUk7SUFDbEI7SUFDQSxPQUFPMEw7QUFDWDtBQUNPLGVBQWUwRiw4QkFBOEIxSyxFQUFFLEVBQUVaLE1BQU0sRUFBRTZDLFVBQVUsRUFBRW5ILE9BQU87SUFDL0UrRixTQUFTYjtJQUNUYyxhQUFhMUI7SUFDYixPQUFPdUkscUJBQXFCM0gsSUFBSVosUUFBUSxzQkFBc0IsSUFBSStDLGdCQUFnQkYsYUFBYW5IO0FBQ25HO0FBQ08sZUFBZTZQLGlDQUFpQzNLLEVBQUUsRUFBRVosTUFBTSxFQUFFN0QsUUFBUTtJQUN2RSxNQUFNeUosU0FBUyxNQUFNb0Qsa0NBQWtDcEksSUFBSVosUUFBUTdELFVBQVUsTUFBTTtJQUNuRixJQUFJNkksY0FBY1ksU0FBUztRQUN2QixPQUFPQTtJQUNYO0lBQ0EsT0FBT0E7QUFDWDtBQUNPLGVBQWU0RixrQkFBa0I1SyxFQUFFLEVBQUVaLE1BQU0sRUFBRWYsS0FBSyxFQUFFdkQsT0FBTztJQUM5RCtGLFNBQVNiO0lBQ1RjLGFBQWExQjtJQUNiLElBQUksQ0FBQ3BDLGVBQWVxQixRQUFRO1FBQ3hCLE1BQU0sSUFBSWxDLFVBQVU7SUFDeEI7SUFDQSxJQUFJLE9BQU82RCxHQUFHNkssbUJBQW1CLEtBQUssVUFBVTtRQUM1QyxNQUFNLElBQUkxTyxVQUFVO0lBQ3hCO0lBQ0EsTUFBTVgsTUFBTSxJQUFJQyxJQUFJdUUsR0FBRzZLLG1CQUFtQjtJQUMxQyxNQUFNeEosT0FBTyxJQUFJYyxnQkFBZ0JySCxTQUFTaU47SUFDMUMxRyxLQUFLakgsR0FBRyxDQUFDLFNBQVNpRTtJQUNsQixNQUFNM0MsVUFBVU8sZUFBZW5CLFNBQVNZO0lBQ3hDQSxRQUFRcEIsTUFBTSxDQUFDO0lBQ2YsT0FBTzZKLHFCQUFxQm5FLElBQUlaLFFBQVEsUUFBUTVELEtBQUs2RixNQUFNM0YsU0FBU1o7QUFDeEU7QUFDTyxlQUFlZ1EsMEJBQTBCdlAsUUFBUTtJQUNwRCxJQUFJLENBQUVBLENBQUFBLG9CQUFvQjRCLFFBQU8sR0FBSTtRQUNqQyxNQUFNLElBQUloQixVQUFVO0lBQ3hCO0lBQ0EsSUFBSVosU0FBUzZCLE1BQU0sS0FBSyxLQUFLO1FBQ3pCLElBQUlxSTtRQUNKLElBQUtBLE1BQU0sTUFBTUMscUJBQXFCbkssV0FBWTtZQUM5QyxPQUFPa0s7UUFDWDtRQUNBLE1BQU0sSUFBSW5NLElBQUk7SUFDbEI7SUFDQSxPQUFPWTtBQUNYO0FBQ0EsU0FBU21ELHVCQUF1QjlCLFFBQVE7SUFDcEMsSUFBSUEsU0FBU3dQLFFBQVEsRUFBRTtRQUNuQixNQUFNLElBQUk1TyxVQUFVO0lBQ3hCO0FBQ0o7QUFDTyxlQUFlNk8scUJBQXFCaEwsRUFBRSxFQUFFWixNQUFNLEVBQUVmLEtBQUssRUFBRXZELE9BQU87SUFDakUrRixTQUFTYjtJQUNUYyxhQUFhMUI7SUFDYixJQUFJLENBQUNwQyxlQUFlcUIsUUFBUTtRQUN4QixNQUFNLElBQUlsQyxVQUFVO0lBQ3hCO0lBQ0EsSUFBSSxPQUFPNkQsR0FBR2lMLHNCQUFzQixLQUFLLFVBQVU7UUFDL0MsTUFBTSxJQUFJOU8sVUFBVTtJQUN4QjtJQUNBLE1BQU1YLE1BQU0sSUFBSUMsSUFBSXVFLEdBQUdpTCxzQkFBc0I7SUFDN0MsTUFBTTVKLE9BQU8sSUFBSWMsZ0JBQWdCckgsU0FBU2lOO0lBQzFDMUcsS0FBS2pILEdBQUcsQ0FBQyxTQUFTaUU7SUFDbEIsTUFBTTNDLFVBQVVPLGVBQWVuQixTQUFTWTtJQUN4QyxJQUFJWixTQUFTb1Esc0JBQXNCOUwsT0FBTytMLGlDQUFpQyxFQUFFO1FBQ3pFelAsUUFBUXRCLEdBQUcsQ0FBQyxVQUFVO0lBQzFCLE9BQ0s7UUFDRHNCLFFBQVF0QixHQUFHLENBQUMsVUFBVTtJQUMxQjtJQUNBLE9BQU8rSixxQkFBcUJuRSxJQUFJWixRQUFRLFFBQVE1RCxLQUFLNkYsTUFBTTNGLFNBQVNaO0FBQ3hFO0FBQ08sZUFBZXNRLDZCQUE2QnBMLEVBQUUsRUFBRVosTUFBTSxFQUFFN0QsUUFBUTtJQUNuRXNGLFNBQVNiO0lBQ1RjLGFBQWExQjtJQUNiLElBQUksQ0FBRTdELENBQUFBLG9CQUFvQjRCLFFBQU8sR0FBSTtRQUNqQyxNQUFNLElBQUloQixVQUFVO0lBQ3hCO0lBQ0EsSUFBSVosU0FBUzZCLE1BQU0sS0FBSyxLQUFLO1FBQ3pCLElBQUlxSTtRQUNKLElBQUtBLE1BQU0sTUFBTUMscUJBQXFCbkssV0FBWTtZQUM5QyxPQUFPa0s7UUFDWDtRQUNBLE1BQU0sSUFBSW5NLElBQUk7SUFDbEI7SUFDQSxJQUFJZ0U7SUFDSixJQUFJMEosZUFBZXpMLGNBQWMsdUNBQXVDO1FBQ3BFOEIsdUJBQXVCOUI7UUFDdkIsTUFBTSxFQUFFNkcsTUFBTSxFQUFFLEdBQUcsTUFBTStFLFlBQVksTUFBTTVMLFNBQVM2TCxJQUFJLElBQUlDLHNCQUFzQkMsSUFBSSxDQUFDcE4sV0FBV2tGLE9BQU8rTCxpQ0FBaUMsRUFBRW5MLEdBQUdxTCwwQ0FBMEMsR0FBRzdELGtCQUFrQnJJLGFBQWFDLFNBQVNHLGtCQUFrQkgsU0FDalByQyxJQUFJLENBQUMwTixhQUFhbkQsSUFBSSxDQUFDcE4sV0FBVyw0QkFDbEM2QyxJQUFJLENBQUM4TCxpQkFBaUJ2QixJQUFJLENBQUNwTixXQUFXO1lBQUM7WUFBTztZQUFPO1NBQU0sR0FDM0Q2QyxJQUFJLENBQUMrTCxlQUFleEIsSUFBSSxDQUFDcE4sV0FBVzhGLEdBQUd6QyxNQUFNLEdBQzdDUixJQUFJLENBQUNnTSxpQkFBaUJ6QixJQUFJLENBQUNwTixXQUFXa0YsT0FBT29CLFNBQVM7UUFDM0RsRCxPQUFPOEUsT0FBT2tKLG1CQUFtQjtRQUNqQyxJQUFJLENBQUN4UCxhQUFhd0IsT0FBTztZQUNyQixNQUFNLElBQUloRSxJQUFJO1FBQ2xCO0lBQ0osT0FDSztRQUNEK0QsdUJBQXVCOUI7UUFDdkIsSUFBSTtZQUNBK0IsT0FBTyxNQUFNL0IsU0FBUytCLElBQUk7UUFDOUIsRUFDQSxPQUFPakUsT0FBTztZQUNWLE1BQU0sSUFBSUMsSUFBSSwyQ0FBMkM7Z0JBQUVEO1lBQU07UUFDckU7UUFDQSxJQUFJLENBQUN5QyxhQUFhd0IsT0FBTztZQUNyQixNQUFNLElBQUloRSxJQUFJO1FBQ2xCO0lBQ0o7SUFDQSxJQUFJLE9BQU9nRSxLQUFLaU8sTUFBTSxLQUFLLFdBQVc7UUFDbEMsTUFBTSxJQUFJalMsSUFBSTtJQUNsQjtJQUNBLE9BQU9nRTtBQUNYO0FBQ0EsZUFBZWlKLFlBQVl2RyxFQUFFLEVBQUVsRixPQUFPO0lBQ2xDK0YsU0FBU2I7SUFDVCxJQUFJLE9BQU9BLEdBQUd3TCxRQUFRLEtBQUssVUFBVTtRQUNqQyxNQUFNLElBQUlyUCxVQUFVO0lBQ3hCO0lBQ0EsTUFBTVgsTUFBTSxJQUFJQyxJQUFJdUUsR0FBR3dMLFFBQVE7SUFDL0IsTUFBTTlQLFVBQVVPLGVBQWVuQixTQUFTWTtJQUN4Q0EsUUFBUXRCLEdBQUcsQ0FBQyxVQUFVO0lBQ3RCc0IsUUFBUXVLLE1BQU0sQ0FBQyxVQUFVO0lBQ3pCLE9BQU9ySixNQUFNcEIsSUFBSWlCLElBQUksRUFBRTtRQUNuQmY7UUFDQW1CLFFBQVE7UUFDUkMsVUFBVTtRQUNWVixRQUFRdEIsU0FBU3NCLFNBQVNBLE9BQU90QixRQUFRc0IsTUFBTSxJQUFJO0lBQ3ZELEdBQUdXLElBQUksQ0FBQ3pCO0FBQ1o7QUFDQSxlQUFla0wsb0JBQW9CakwsUUFBUTtJQUN2QyxJQUFJLENBQUVBLENBQUFBLG9CQUFvQjRCLFFBQU8sR0FBSTtRQUNqQyxNQUFNLElBQUloQixVQUFVO0lBQ3hCO0lBQ0EsSUFBSVosU0FBUzZCLE1BQU0sS0FBSyxLQUFLO1FBQ3pCLE1BQU0sSUFBSTlELElBQUk7SUFDbEI7SUFDQStELHVCQUF1QjlCO0lBQ3ZCLElBQUkrQjtJQUNKLElBQUk7UUFDQUEsT0FBTyxNQUFNL0IsU0FBUytCLElBQUk7SUFDOUIsRUFDQSxPQUFPakUsT0FBTztRQUNWLE1BQU0sSUFBSUMsSUFBSSwyQ0FBMkM7WUFBRUQ7UUFBTTtJQUNyRTtJQUNBLElBQUksQ0FBQ3lDLGFBQWF3QixPQUFPO1FBQ3JCLE1BQU0sSUFBSWhFLElBQUk7SUFDbEI7SUFDQSxJQUFJLENBQUN5QyxNQUFNQyxPQUFPLENBQUNzQixLQUFLb0osSUFBSSxHQUFHO1FBQzNCLE1BQU0sSUFBSXBOLElBQUk7SUFDbEI7SUFDQSxJQUFJLENBQUN5QyxNQUFNMFAsU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQ3JPLEtBQUtvSixJQUFJLEVBQUU1SyxlQUFlO1FBQ3RELE1BQU0sSUFBSXhDLElBQUk7SUFDbEI7SUFDQSxPQUFPZ0U7QUFDWDtBQUNBLGVBQWVvSSxxQkFBcUJuSyxRQUFRO0lBQ3hDLElBQUlBLFNBQVM2QixNQUFNLEdBQUcsT0FBTzdCLFNBQVM2QixNQUFNLEdBQUcsS0FBSztRQUNoREMsdUJBQXVCOUI7UUFDdkIsSUFBSTtZQUNBLE1BQU0rQixPQUFPLE1BQU0vQixTQUFTK0IsSUFBSTtZQUNoQyxJQUFJeEIsYUFBYXdCLFNBQVMsT0FBT0EsS0FBSytHLEtBQUssS0FBSyxZQUFZL0csS0FBSytHLEtBQUssQ0FBQ2xMLE1BQU0sRUFBRTtnQkFDM0UsSUFBSW1FLEtBQUtzTyxpQkFBaUIsS0FBSzFSLGFBQWEsT0FBT29ELEtBQUtzTyxpQkFBaUIsS0FBSyxVQUFVO29CQUNwRixPQUFPdE8sS0FBS3NPLGlCQUFpQjtnQkFDakM7Z0JBQ0EsSUFBSXRPLEtBQUt1TyxTQUFTLEtBQUszUixhQUFhLE9BQU9vRCxLQUFLdU8sU0FBUyxLQUFLLFVBQVU7b0JBQ3BFLE9BQU92TyxLQUFLdU8sU0FBUztnQkFDekI7Z0JBQ0EsSUFBSXZPLEtBQUt3TyxJQUFJLEtBQUs1UixhQUFhLE9BQU9vRCxLQUFLd08sSUFBSSxLQUFLLFVBQVU7b0JBQzFELE9BQU94TyxLQUFLd08sSUFBSTtnQkFDcEI7Z0JBQ0EsSUFBSXhPLEtBQUtvTCxLQUFLLEtBQUt4TyxhQUFhLE9BQU9vRCxLQUFLb0wsS0FBSyxLQUFLLFVBQVU7b0JBQzVELE9BQU9wTCxLQUFLb0wsS0FBSztnQkFDckI7Z0JBQ0EsT0FBT3BMO1lBQ1g7UUFDSixFQUNBLE9BQU0sQ0FBRTtJQUNaO0lBQ0EsT0FBT3BEO0FBQ1g7QUFDQSxTQUFTa00scUJBQXFCeEYsR0FBRztJQUM3QixJQUFJLENBQUN2RixtQkFBbUJzRyxRQUFRLENBQUNmLE1BQU07UUFDbkMsTUFBTSxJQUFJcEcsMEJBQTBCO0lBQ3hDO0lBQ0EsT0FBT29HO0FBQ1g7QUFDQSxTQUFTbUwscUJBQXFCclAsU0FBUztJQUNuQyxJQUFJLE9BQU9BLFVBQVVzUCxhQUFhLEtBQUssWUFBWXRQLFVBQVVzUCxhQUFhLEdBQUcsTUFBTTtRQUMvRSxNQUFNLElBQUkxUyxJQUFJLENBQUMsRUFBRW9ELFVBQVUvQixJQUFJLENBQUMseUNBQXlDLENBQUM7SUFDOUU7QUFDSjtBQUNBLFNBQVNzUixjQUFjaE4sVUFBVTtJQUM3QixPQUFRQTtRQUNKLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYO1lBQ0ksTUFBTSxJQUFJekU7SUFDbEI7QUFDSjtBQUNBLFNBQVN1SCxZQUFZaEksR0FBRztJQUNwQixPQUFRQSxJQUFJMkMsU0FBUyxDQUFDL0IsSUFBSTtRQUN0QixLQUFLO1lBQ0QsT0FBTztnQkFDSEEsTUFBTVosSUFBSTJDLFNBQVMsQ0FBQy9CLElBQUk7Z0JBQ3hCbUUsTUFBTW1OLGNBQWNsUyxJQUFJMkMsU0FBUyxDQUFDdUMsVUFBVTtZQUNoRDtRQUNKLEtBQUs7WUFBVztnQkFDWjhNLHFCQUFxQmhTLElBQUkyQyxTQUFTO2dCQUNsQyxPQUFRM0MsSUFBSTJDLFNBQVMsQ0FBQ29DLElBQUksQ0FBQ25FLElBQUk7b0JBQzNCLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO3dCQUNELE9BQU87NEJBQ0hBLE1BQU1aLElBQUkyQyxTQUFTLENBQUMvQixJQUFJOzRCQUN4QnVSLFlBQVlDLFNBQVNwUyxJQUFJMkMsU0FBUyxDQUFDb0MsSUFBSSxDQUFDbkUsSUFBSSxDQUFDNEosS0FBSyxDQUFDLENBQUMsSUFBSSxPQUFPO3dCQUNuRTtvQkFDSjt3QkFDSSxNQUFNLElBQUkvSjtnQkFDbEI7WUFDSjtRQUNBLEtBQUs7WUFDRHVSLHFCQUFxQmhTLElBQUkyQyxTQUFTO1lBQ2xDLE9BQU8zQyxJQUFJMkMsU0FBUyxDQUFDL0IsSUFBSTtRQUM3QixLQUFLO1FBQ0wsS0FBSztZQUNELE9BQU9aLElBQUkyQyxTQUFTLENBQUMvQixJQUFJO0lBQ2pDO0lBQ0EsTUFBTSxJQUFJSDtBQUNkO0FBQ0EsTUFBTWdOLG1CQUFtQmxRO0FBQ3pCLGVBQWU2UCxZQUFZaUYsR0FBRyxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRWpWLFNBQVMsRUFBRUUsY0FBYztJQUN2RSxNQUFNLEVBQUUsR0FBR2dWLGVBQWUsRUFBRSxHQUFHQyxPQUFPLEVBQUUsR0FBR0MsZ0JBQWdCLEVBQUV0VCxNQUFNLEVBQUUsR0FBR2lULElBQUl2SCxLQUFLLENBQUM7SUFDbEYsSUFBSTFMLFdBQVcsR0FBRztRQUNkLE1BQU0sSUFBSXFCLDBCQUEwQjtJQUN4QztJQUNBLElBQUlyQixXQUFXLEdBQUc7UUFDZCxNQUFNLElBQUlHLElBQUk7SUFDbEI7SUFDQSxJQUFJa0k7SUFDSixJQUFJO1FBQ0FBLFNBQVNJLEtBQUtjLEtBQUssQ0FBQzlLLElBQUkyQixLQUFLZ1Q7SUFDakMsRUFDQSxPQUFPbFQsT0FBTztRQUNWLE1BQU0sSUFBSUMsSUFBSSw2REFBNkQ7WUFBRUQ7UUFBTTtJQUN2RjtJQUNBLElBQUksQ0FBQ3lDLGFBQWEwRixTQUFTO1FBQ3ZCLE1BQU0sSUFBSWxJLElBQUk7SUFDbEI7SUFDQStTLFNBQVM3SztJQUNULElBQUlBLE9BQU9rTCxJQUFJLEtBQUt4UyxXQUFXO1FBQzNCLE1BQU0sSUFBSVosSUFBSTtJQUNsQjtJQUNBLE1BQU13SSxZQUFZdkksS0FBS2tUO0lBQ3ZCLElBQUlILFdBQVc5RSxrQkFBa0I7UUFDN0IsTUFBTXpOLE1BQU0sTUFBTXVTLE9BQU85SztRQUN6QixNQUFNM0osUUFBUSxDQUFDLEVBQUUwVSxnQkFBZ0IsQ0FBQyxFQUFFQyxRQUFRLENBQUM7UUFDN0MsTUFBTUcsV0FBVyxNQUFNbFAsT0FBT08sTUFBTSxDQUFDNE8sTUFBTSxDQUFDN0ssWUFBWWhJLE1BQU1BLEtBQUsrSCxXQUFXbEssSUFBSUM7UUFDbEYsSUFBSSxDQUFDOFUsVUFBVTtZQUNYLE1BQU0sSUFBSXJULElBQUk7UUFDbEI7SUFDSjtJQUNBLElBQUk4STtJQUNKLElBQUk7UUFDQUEsU0FBU1IsS0FBS2MsS0FBSyxDQUFDOUssSUFBSTJCLEtBQUtpVDtJQUNqQyxFQUNBLE9BQU9uVCxPQUFPO1FBQ1YsTUFBTSxJQUFJQyxJQUFJLDhEQUE4RDtZQUFFRDtRQUFNO0lBQ3hGO0lBQ0EsSUFBSSxDQUFDeUMsYUFBYXNHLFNBQVM7UUFDdkIsTUFBTSxJQUFJOUksSUFBSTtJQUNsQjtJQUNBLE1BQU13RyxNQUFNSCxjQUFjdEk7SUFDMUIsSUFBSStLLE9BQU9oQyxHQUFHLEtBQUtsRyxXQUFXO1FBQzFCLElBQUksT0FBT2tJLE9BQU9oQyxHQUFHLEtBQUssVUFBVTtZQUNoQyxNQUFNLElBQUk5RyxJQUFJO1FBQ2xCO1FBQ0EsSUFBSThJLE9BQU9oQyxHQUFHLElBQUlOLE1BQU12SSxnQkFBZ0I7WUFDcEMsTUFBTSxJQUFJK0IsSUFBSTtRQUNsQjtJQUNKO0lBQ0EsSUFBSThJLE9BQU8vQixHQUFHLEtBQUtuRyxXQUFXO1FBQzFCLElBQUksT0FBT2tJLE9BQU8vQixHQUFHLEtBQUssVUFBVTtZQUNoQyxNQUFNLElBQUkvRyxJQUFJO1FBQ2xCO0lBQ0o7SUFDQSxJQUFJOEksT0FBTzdCLEdBQUcsS0FBS3JHLFdBQVc7UUFDMUIsSUFBSSxPQUFPa0ksT0FBTzdCLEdBQUcsS0FBSyxVQUFVO1lBQ2hDLE1BQU0sSUFBSWpILElBQUk7UUFDbEI7SUFDSjtJQUNBLElBQUk4SSxPQUFPOUIsR0FBRyxLQUFLcEcsV0FBVztRQUMxQixJQUFJLE9BQU9rSSxPQUFPOUIsR0FBRyxLQUFLLFVBQVU7WUFDaEMsTUFBTSxJQUFJaEgsSUFBSTtRQUNsQjtRQUNBLElBQUk4SSxPQUFPOUIsR0FBRyxHQUFHUixNQUFNdkksZ0JBQWdCO1lBQ25DLE1BQU0sSUFBSStCLElBQUk7UUFDbEI7SUFDSjtJQUNBLElBQUk4SSxPQUFPbEMsR0FBRyxLQUFLaEcsV0FBVztRQUMxQixJQUFJLE9BQU9rSSxPQUFPbEMsR0FBRyxLQUFLLFlBQVksQ0FBQ25FLE1BQU1DLE9BQU8sQ0FBQ29HLE9BQU9sQyxHQUFHLEdBQUc7WUFDOUQsTUFBTSxJQUFJNUcsSUFBSTtRQUNsQjtJQUNKO0lBQ0EsT0FBTztRQUFFa0k7UUFBUVk7UUFBUU47SUFBVTtBQUN2QztBQUNPLGVBQWUrSyx3QkFBd0I3TSxFQUFFLEVBQUVaLE1BQU0sRUFBRTZDLFVBQVUsRUFBRTZLLGFBQWEsRUFBRWhTLE9BQU87SUFDeEYrRixTQUFTYjtJQUNUYyxhQUFhMUI7SUFDYixJQUFJNkMsc0JBQXNCeEcsS0FBSztRQUMzQndHLGFBQWFBLFdBQVd1SCxZQUFZO0lBQ3hDO0lBQ0EsSUFBSSxDQUFFdkgsQ0FBQUEsc0JBQXNCRSxlQUFjLEdBQUk7UUFDMUMsTUFBTSxJQUFJaEcsVUFBVTtJQUN4QjtJQUNBLE1BQU1aLFdBQVd1TyxzQkFBc0I3SCxZQUFZO0lBQ25ELElBQUksQ0FBQzFHLFVBQVU7UUFDWCxNQUFNLElBQUlqQyxJQUFJO0lBQ2xCO0lBQ0EsSUFBSSxPQUFPMEcsR0FBR3dMLFFBQVEsS0FBSyxVQUFVO1FBQ2pDLE1BQU0sSUFBSXJQLFVBQVU7SUFDeEI7SUFDQSxNQUFNLEVBQUVpRyxNQUFNLEVBQUUsR0FBRyxNQUFNK0UsWUFBWTVMLFVBQVU4TCxzQkFBc0JDLElBQUksQ0FBQ3BOLFdBQVdrRixPQUFPMk4saUNBQWlDLEVBQUUvTSxHQUFHZ04sMENBQTBDLEdBQUc3RyxpQ0FBaUNtQixJQUFJLENBQUNwTixXQUFXOEYsSUFBSWxGLFVBQVVxRSxhQUFhQyxTQUFTRyxrQkFBa0JILFNBQ2pSckMsSUFBSSxDQUFDOEwsaUJBQWlCdkIsSUFBSSxDQUFDcE4sV0FBVztRQUFDO1FBQU87UUFBTztLQUFNLEdBQzNENkMsSUFBSSxDQUFDK0wsZUFBZXhCLElBQUksQ0FBQ3BOLFdBQVc4RixHQUFHekMsTUFBTSxHQUM3Q1IsSUFBSSxDQUFDZ00saUJBQWlCekIsSUFBSSxDQUFDcE4sV0FBV2tGLE9BQU9vQixTQUFTO0lBQzNELE1BQU13RSxTQUFTLElBQUk3QztJQUNuQixLQUFLLE1BQU0sQ0FBQ3BJLEtBQUtNLE1BQU0sSUFBSWdJLE9BQU9FLE9BQU8sQ0FBQ0gsUUFBUztRQUMvQyxJQUFJLE9BQU8vSCxVQUFVLFlBQVlOLFFBQVEsT0FBTztZQUM1Q2lMLE9BQU81SyxHQUFHLENBQUNMLEtBQUtNO1FBQ3BCO0lBQ0o7SUFDQSxPQUFPNFMscUJBQXFCak4sSUFBSVosUUFBUTRGLFFBQVE4SDtBQUNwRDtBQUNBLFNBQVN6RixzQkFBc0JqSSxNQUFNLEVBQUU3QixNQUFNLEVBQUVpRSxNQUFNO0lBQ2pELElBQUlwQyxXQUFXbEYsV0FBVztRQUN0QixJQUFJc0gsT0FBT1osR0FBRyxLQUFLeEIsUUFBUTtZQUN2QixNQUFNLElBQUk5RixJQUFJO1FBQ2xCO1FBQ0E7SUFDSjtJQUNBLElBQUl5QyxNQUFNQyxPQUFPLENBQUN1QixTQUFTO1FBQ3ZCLElBQUksQ0FBQ0EsT0FBT29FLFFBQVEsQ0FBQ0gsT0FBT1osR0FBRyxHQUFHO1lBQzlCLE1BQU0sSUFBSXRILElBQUk7UUFDbEI7UUFDQTtJQUNKO0lBQ0EsSUFBSWtJLE9BQU9aLEdBQUcsS0FBSyxTQUFTO1FBQ3hCLE1BQU0sSUFBSXRILElBQUk7SUFDbEI7QUFDSjtBQUNBLFNBQVN3USxzQkFBc0I3SCxVQUFVLEVBQUV0SCxJQUFJO0lBQzNDLE1BQU0sRUFBRSxHQUFHTixLQUFLLEVBQUVsQixNQUFNLEVBQUUsR0FBRzhJLFdBQVdRLE1BQU0sQ0FBQzlIO0lBQy9DLElBQUl4QixTQUFTLEdBQUc7UUFDWixNQUFNLElBQUlHLElBQUksQ0FBQyxDQUFDLEVBQUVxQixLQUFLLHNDQUFzQyxDQUFDO0lBQ2xFO0lBQ0EsT0FBT047QUFDWDtBQUNPLE1BQU02UyxpQkFBaUI1VixTQUFTO0FBQ2hDLE1BQU02VixnQkFBZ0I3VixTQUFTO0FBQy9CLFNBQVMyVixxQkFBcUJqTixFQUFFLEVBQUVaLE1BQU0sRUFBRTZDLFVBQVUsRUFBRTZLLGFBQWE7SUFDdEVqTSxTQUFTYjtJQUNUYyxhQUFhMUI7SUFDYixJQUFJNkMsc0JBQXNCeEcsS0FBSztRQUMzQndHLGFBQWFBLFdBQVd1SCxZQUFZO0lBQ3hDO0lBQ0EsSUFBSSxDQUFFdkgsQ0FBQUEsc0JBQXNCRSxlQUFjLEdBQUk7UUFDMUMsTUFBTSxJQUFJaEcsVUFBVTtJQUN4QjtJQUNBLElBQUkyTixzQkFBc0I3SCxZQUFZLGFBQWE7UUFDL0MsTUFBTSxJQUFJM0ksSUFBSTtJQUNsQjtJQUNBLE1BQU1pSCxNQUFNdUosc0JBQXNCN0gsWUFBWTtJQUM5QyxNQUFNbUwsUUFBUXRELHNCQUFzQjdILFlBQVk7SUFDaEQsSUFBSSxDQUFDMUIsT0FBT1AsR0FBR3FOLDhDQUE4QyxFQUFFO1FBQzNELE1BQU0sSUFBSS9ULElBQUk7SUFDbEI7SUFDQSxJQUFJaUgsT0FBT0EsUUFBUVAsR0FBR3pDLE1BQU0sRUFBRTtRQUMxQixNQUFNLElBQUlqRSxJQUFJO0lBQ2xCO0lBQ0EsT0FBUXdUO1FBQ0osS0FBSzVTO1FBQ0wsS0FBS2lUO1lBQ0QsSUFBSUMsVUFBVWxULFdBQVc7Z0JBQ3JCLE1BQU0sSUFBSVosSUFBSTtZQUNsQjtZQUNBO1FBQ0osS0FBSzRUO1lBQ0Q7UUFDSjtZQUNJLElBQUksQ0FBQ2xRLGVBQWU4UCxnQkFBZ0I7Z0JBQ2hDLE1BQU0sSUFBSXhULElBQUk7WUFDbEI7WUFDQSxJQUFJOFQsVUFBVWxULFdBQVc7Z0JBQ3JCLE1BQU0sSUFBSVosSUFBSTtZQUNsQjtZQUNBLElBQUk4VCxVQUFVTixlQUFlO2dCQUN6QixNQUFNLElBQUl4VCxJQUFJO1lBQ2xCO0lBQ1I7SUFDQSxNQUFNK0ssUUFBUXlGLHNCQUFzQjdILFlBQVk7SUFDaEQsSUFBSW9DLE9BQU87UUFDUCxPQUFPO1lBQ0hBO1lBQ0F1SCxtQkFBbUI5QixzQkFBc0I3SCxZQUFZO1lBQ3JENEosV0FBVy9CLHNCQUFzQjdILFlBQVk7UUFDakQ7SUFDSjtJQUNBLE1BQU1rRyxXQUFXMkIsc0JBQXNCN0gsWUFBWTtJQUNuRCxNQUFNNUQsUUFBUXlMLHNCQUFzQjdILFlBQVk7SUFDaEQsSUFBSWtHLGFBQWFqTyxhQUFhbUUsVUFBVW5FLFdBQVc7UUFDL0MsTUFBTSxJQUFJTSwwQkFBMEI7SUFDeEM7SUFDQSxPQUFPK08sTUFBTSxJQUFJcEgsZ0JBQWdCRjtBQUNyQztBQUNBLFNBQVNxTCxZQUFZMU0sR0FBRyxFQUFFa0QsR0FBRztJQUN6QixPQUFRbEQ7UUFDSixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDRCxPQUFPO2dCQUFFakcsTUFBTTtnQkFBV21FLE1BQU0sQ0FBQyxJQUFJLEVBQUU4QixJQUFJMkQsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDO1lBQUM7UUFDM0QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0QsT0FBTztnQkFBRTVKLE1BQU07Z0JBQXFCbUUsTUFBTSxDQUFDLElBQUksRUFBRThCLElBQUkyRCxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUM7WUFBQztRQUNyRSxLQUFLO1FBQ0wsS0FBSztZQUNELE9BQU87Z0JBQUU1SixNQUFNO2dCQUFTc0UsWUFBWSxDQUFDLEVBQUUsRUFBRTJCLElBQUkyRCxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUM7WUFBQztRQUM3RCxLQUFLO1lBQ0QsT0FBTztnQkFBRTVKLE1BQU07Z0JBQVNzRSxZQUFZO1lBQVE7UUFDaEQsS0FBSztZQUFTO2dCQUNWLE9BQVE2RTtvQkFDSixLQUFLO29CQUNMLEtBQUs7d0JBQ0QsT0FBT0E7b0JBQ1g7d0JBQ0ksTUFBTSxJQUFJdEo7Z0JBQ2xCO1lBQ0o7UUFDQTtZQUNJLE1BQU0sSUFBSUE7SUFDbEI7QUFDSjtBQUNBLGVBQWVzTSxVQUFVbEcsR0FBRyxFQUFFdUMsR0FBRztJQUM3QixNQUFNLEVBQUVvSyxHQUFHLEVBQUUxRyxPQUFPLEVBQUVELEdBQUcsRUFBRSxHQUFHN00sS0FBSyxHQUFHb0o7SUFDdEMsT0FBTzFGLE9BQU9PLE1BQU0sQ0FBQ3dQLFNBQVMsQ0FBQyxPQUFPelQsS0FBS3VULFlBQVkxTSxLQUFLdUMsSUFBSVcsR0FBRyxHQUFHLE1BQU07UUFBQztLQUFTO0FBQzFGO0FBQ08sZUFBZTJKLDJCQUEyQnpOLEVBQUUsRUFBRVosTUFBTSxFQUFFNkMsVUFBVSxFQUFFbkgsT0FBTztJQUM1RStGLFNBQVNiO0lBQ1RjLGFBQWExQjtJQUNiLElBQUksT0FBT1ksR0FBRzBOLDZCQUE2QixLQUFLLFVBQVU7UUFDdEQsTUFBTSxJQUFJdlIsVUFBVTtJQUN4QjtJQUNBLE1BQU1YLE1BQU0sSUFBSUMsSUFBSXVFLEdBQUcwTiw2QkFBNkI7SUFDcEQsTUFBTXJNLE9BQU8sSUFBSWMsZ0JBQWdCRjtJQUNqQ1osS0FBS2pILEdBQUcsQ0FBQyxhQUFhZ0YsT0FBT29CLFNBQVM7SUFDdEMsTUFBTTlFLFVBQVVPLGVBQWVuQixTQUFTWTtJQUN4Q0EsUUFBUXRCLEdBQUcsQ0FBQyxVQUFVO0lBQ3RCLE9BQU8rSixxQkFBcUJuRSxJQUFJWixRQUFRLFFBQVE1RCxLQUFLNkYsTUFBTTNGLFNBQVNaO0FBQ3hFO0FBQ08sZUFBZTZTLG1DQUFtQzNOLEVBQUUsRUFBRVosTUFBTSxFQUFFN0QsUUFBUTtJQUN6RXNGLFNBQVNiO0lBQ1RjLGFBQWExQjtJQUNiLElBQUksQ0FBRTdELENBQUFBLG9CQUFvQjRCLFFBQU8sR0FBSTtRQUNqQyxNQUFNLElBQUloQixVQUFVO0lBQ3hCO0lBQ0EsSUFBSVosU0FBUzZCLE1BQU0sS0FBSyxLQUFLO1FBQ3pCLElBQUlxSTtRQUNKLElBQUtBLE1BQU0sTUFBTUMscUJBQXFCbkssV0FBWTtZQUM5QyxPQUFPa0s7UUFDWDtRQUNBLE1BQU0sSUFBSW5NLElBQUk7SUFDbEI7SUFDQStELHVCQUF1QjlCO0lBQ3ZCLElBQUkrQjtJQUNKLElBQUk7UUFDQUEsT0FBTyxNQUFNL0IsU0FBUytCLElBQUk7SUFDOUIsRUFDQSxPQUFPakUsT0FBTztRQUNWLE1BQU0sSUFBSUMsSUFBSSwyQ0FBMkM7WUFBRUQ7UUFBTTtJQUNyRTtJQUNBLElBQUksQ0FBQ3lDLGFBQWF3QixPQUFPO1FBQ3JCLE1BQU0sSUFBSWhFLElBQUk7SUFDbEI7SUFDQSxJQUFJLENBQUMwRCxlQUFlTSxLQUFLc1EsV0FBVyxHQUFHO1FBQ25DLE1BQU0sSUFBSXRVLElBQUk7SUFDbEI7SUFDQSxJQUFJLENBQUMwRCxlQUFlTSxLQUFLdVEsU0FBUyxHQUFHO1FBQ2pDLE1BQU0sSUFBSXZVLElBQUk7SUFDbEI7SUFDQSxJQUFJLENBQUMwRCxlQUFlTSxLQUFLd1EsZ0JBQWdCLEdBQUc7UUFDeEMsTUFBTSxJQUFJeFUsSUFBSTtJQUNsQjtJQUNBLElBQUksT0FBT2dFLEtBQUtzSSxVQUFVLEtBQUssWUFBWXRJLEtBQUtzSSxVQUFVLElBQUksR0FBRztRQUM3RCxNQUFNLElBQUl0TSxJQUFJO0lBQ2xCO0lBQ0EsSUFBSWdFLEtBQUt5USx5QkFBeUIsS0FBSzdULGFBQ25DLENBQUM4QyxlQUFlTSxLQUFLeVEseUJBQXlCLEdBQUc7UUFDakQsTUFBTSxJQUFJelUsSUFBSTtJQUNsQjtJQUNBLElBQUlnRSxLQUFLMFEsUUFBUSxLQUFLOVQsYUFBYyxRQUFPb0QsS0FBSzBRLFFBQVEsS0FBSyxZQUFZMVEsS0FBSzBRLFFBQVEsSUFBSSxJQUFJO1FBQzFGLE1BQU0sSUFBSTFVLElBQUk7SUFDbEI7SUFDQSxPQUFPZ0U7QUFDWDtBQUNPLGVBQWUyUSx1QkFBdUJqTyxFQUFFLEVBQUVaLE1BQU0sRUFBRThPLFVBQVUsRUFBRXBULE9BQU87SUFDeEUrRixTQUFTYjtJQUNUYyxhQUFhMUI7SUFDYixJQUFJLENBQUNwQyxlQUFla1IsYUFBYTtRQUM3QixNQUFNLElBQUkvUixVQUFVO0lBQ3hCO0lBQ0EsTUFBTThGLGFBQWEsSUFBSUUsZ0JBQWdCckgsU0FBU2lOO0lBQ2hEOUYsV0FBVzdILEdBQUcsQ0FBQyxlQUFlOFQ7SUFDOUIsT0FBT3ZHLHFCQUFxQjNILElBQUlaLFFBQVEsZ0RBQWdENkMsWUFBWW5IO0FBQ3hHO0FBQ08sZUFBZXFULDBCQUEwQm5PLEVBQUUsRUFBRVosTUFBTSxFQUFFN0QsUUFBUTtJQUNoRSxPQUFPNk0sa0NBQWtDcEksSUFBSVosUUFBUTdEO0FBQ3pEO0FBQ08sZUFBZTZTLGdCQUFnQnhOLEdBQUcsRUFBRTlGLE9BQU87SUFDOUMsSUFBSSxDQUFDa0MsZUFBZTRELE1BQU07UUFDdEIsTUFBTSxJQUFJekUsVUFBVTtJQUN4QjtJQUNBLE1BQU1PLFlBQVk0USxZQUFZMU0sS0FBS0EsUUFBUSxVQUFVOUYsU0FBU2dKLE9BQU8sWUFBWTVKO0lBQ2pGLElBQUkwRyxJQUFJMUosVUFBVSxDQUFDLFNBQVMwSixJQUFJMUosVUFBVSxDQUFDLE9BQU87UUFDOUNtTCxPQUFPZ00sTUFBTSxDQUFDM1IsV0FBVztZQUNyQnNQLGVBQWVsUixTQUFTa1IsaUJBQWlCO1lBQ3pDc0MsZ0JBQWdCLElBQUluVyxXQUFXO2dCQUFDO2dCQUFNO2dCQUFNO2FBQUs7UUFDckQ7SUFDSjtJQUNBLE9BQVFzRixPQUFPTyxNQUFNLENBQUN1USxXQUFXLENBQUM3UixXQUFXNUIsU0FBU21JLGVBQWUsT0FBTztRQUFDO1FBQVE7S0FBUztBQUNsRyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYXV0aDR3ZWJhcGkvYnVpbGQvaW5kZXguanM/M2Q0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgVVNFUl9BR0VOVDtcbmlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLnVzZXJBZ2VudD8uc3RhcnRzV2l0aD8uKCdNb3ppbGxhLzUuMCAnKSkge1xuICAgIGNvbnN0IE5BTUUgPSAnb2F1dGg0d2ViYXBpJztcbiAgICBjb25zdCBWRVJTSU9OID0gJ3YyLjQuMCc7XG4gICAgVVNFUl9BR0VOVCA9IGAke05BTUV9LyR7VkVSU0lPTn1gO1xufVxuZXhwb3J0IGNvbnN0IGNsb2NrU2tldyA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IGNsb2NrVG9sZXJhbmNlID0gU3ltYm9sKCk7XG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5mdW5jdGlvbiBidWYoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoaW5wdXQpO1xufVxuY29uc3QgQ0hVTktfU0laRSA9IDB4ODAwMDtcbmZ1bmN0aW9uIGVuY29kZUJhc2U2NFVybChpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH1cbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0LmJ5dGVMZW5ndGg7IGkgKz0gQ0hVTktfU0laRSkge1xuICAgICAgICBhcnIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGlucHV0LnN1YmFycmF5KGksIGkgKyBDSFVOS19TSVpFKSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShhcnIuam9pbignJykpLnJlcGxhY2UoLz0vZywgJycpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xufVxuZnVuY3Rpb24gZGVjb2RlQmFzZTY0VXJsKGlucHV0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmluYXJ5ID0gYXRvYihpbnB1dC5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvXy9nLCAnLycpLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnl0ZXNbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdUaGUgaW5wdXQgdG8gYmUgZGVjb2RlZCBpcyBub3QgY29ycmVjdGx5IGVuY29kZWQuJywgeyBjYXVzZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBiNjR1KGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZUJhc2U2NFVybChpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVCYXNlNjRVcmwoaW5wdXQpO1xufVxuY2xhc3MgTFJVIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhTaXplKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1heFNpemUgPSBtYXhTaXplO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGxldCB2ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIGlmICgodiA9IHRoaXMuX2NhY2hlLmdldChrZXkpKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoa2V5LCB2KTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKGtleSkgfHwgdGhpcy5fY2FjaGUuaGFzKGtleSk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVwZGF0ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZS5zaXplID49IHRoaXMubWF4U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSA/PyAnb3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT8uKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBPcGVyYXRpb25Qcm9jZXNzaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT8uKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbn1cbmNvbnN0IE9QRSA9IE9wZXJhdGlvblByb2Nlc3NpbmdFcnJvcjtcbmNvbnN0IGRwb3BOb25jZXMgPSBuZXcgTFJVKDEwMCk7XG5mdW5jdGlvbiBpc0NyeXB0b0tleShrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluc3RhbmNlb2YgQ3J5cHRvS2V5O1xufVxuZnVuY3Rpb24gaXNQcml2YXRlS2V5KGtleSkge1xuICAgIHJldHVybiBpc0NyeXB0b0tleShrZXkpICYmIGtleS50eXBlID09PSAncHJpdmF0ZSc7XG59XG5mdW5jdGlvbiBpc1B1YmxpY0tleShrZXkpIHtcbiAgICByZXR1cm4gaXNDcnlwdG9LZXkoa2V5KSAmJiBrZXkudHlwZSA9PT0gJ3B1YmxpYyc7XG59XG5jb25zdCBTVVBQT1JURURfSldTX0FMR1MgPSBbXG4gICAgJ1BTMjU2JyxcbiAgICAnRVMyNTYnLFxuICAgICdSUzI1NicsXG4gICAgJ1BTMzg0JyxcbiAgICAnRVMzODQnLFxuICAgICdSUzM4NCcsXG4gICAgJ1BTNTEyJyxcbiAgICAnRVM1MTInLFxuICAgICdSUzUxMicsXG4gICAgJ0VkRFNBJyxcbl07XG5mdW5jdGlvbiBwcm9jZXNzRHBvcE5vbmNlKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXNwb25zZS51cmwpO1xuICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmhhcygnZHBvcC1ub25jZScpKSB7XG4gICAgICAgIGRwb3BOb25jZXMuc2V0KHVybC5vcmlnaW4sIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdkcG9wLW5vbmNlJykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5mdW5jdGlvbiBub3JtYWxpemVUeXAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eYXBwbGljYXRpb25cXC8vLCAnJyk7XG59XG5mdW5jdGlvbiBpc0pzb25PYmplY3QoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcHJlcGFyZUhlYWRlcnMoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgIT09IHVuZGVmaW5lZCAmJiAhKGlucHV0IGluc3RhbmNlb2YgSGVhZGVycykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmhlYWRlcnNcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEhlYWRlcnMnKTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0KTtcbiAgICBpZiAoVVNFUl9BR0VOVCAmJiAhaGVhZGVycy5oYXMoJ3VzZXItYWdlbnQnKSkge1xuICAgICAgICBoZWFkZXJzLnNldCgndXNlci1hZ2VudCcsIFVTRVJfQUdFTlQpO1xuICAgIH1cbiAgICBpZiAoaGVhZGVycy5oYXMoJ2F1dGhvcml6YXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuaGVhZGVyc1wiIG11c3Qgbm90IGluY2x1ZGUgdGhlIFwiYXV0aG9yaXphdGlvblwiIGhlYWRlciBuYW1lJyk7XG4gICAgfVxuICAgIGlmIChoZWFkZXJzLmhhcygnZHBvcCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5oZWFkZXJzXCIgbXVzdCBub3QgaW5jbHVkZSB0aGUgXCJkcG9wXCIgaGVhZGVyIG5hbWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBzaWduYWwodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICB9XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLnNpZ25hbFwiIG11c3QgcmV0dXJuIG9yIGJlIGFuIGluc3RhbmNlIG9mIEFib3J0U2lnbmFsJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaXNjb3ZlcnlSZXF1ZXN0KGlzc3VlcklkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShpc3N1ZXJJZGVudGlmaWVyIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlzc3VlcklkZW50aWZpZXJcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTCcpO1xuICAgIH1cbiAgICBpZiAoaXNzdWVySWRlbnRpZmllci5wcm90b2NvbCAhPT0gJ2h0dHBzOicgJiYgaXNzdWVySWRlbnRpZmllci5wcm90b2NvbCAhPT0gJ2h0dHA6Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlzc3Vlci5wcm90b2NvbFwiIG11c3QgYmUgXCJodHRwczpcIiBvciBcImh0dHA6XCInKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChpc3N1ZXJJZGVudGlmaWVyLmhyZWYpO1xuICAgIHN3aXRjaCAob3B0aW9ucz8uYWxnb3JpdGhtKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlICdvaWRjJzpcbiAgICAgICAgICAgIHVybC5wYXRobmFtZSA9IGAke3VybC5wYXRobmFtZX0vLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25gLnJlcGxhY2UoJy8vJywgJy8nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvYXV0aDInOlxuICAgICAgICAgICAgaWYgKHVybC5wYXRobmFtZSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgdXJsLnBhdGhuYW1lID0gYC53ZWxsLWtub3duL29hdXRoLWF1dGhvcml6YXRpb24tc2VydmVyYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybC5wYXRobmFtZSA9IGAud2VsbC1rbm93bi9vYXV0aC1hdXRob3JpemF0aW9uLXNlcnZlci8ke3VybC5wYXRobmFtZX1gLnJlcGxhY2UoJy8vJywgJy8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLmFsZ29yaXRobVwiIG11c3QgYmUgXCJvaWRjXCIgKGRlZmF1bHQpLCBvciBcIm9hdXRoMlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICByZXR1cm4gZmV0Y2godXJsLmhyZWYsIHtcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgcmVkaXJlY3Q6ICdtYW51YWwnLFxuICAgICAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCA/IHNpZ25hbChvcHRpb25zLnNpZ25hbCkgOiBudWxsLFxuICAgIH0pLnRoZW4ocHJvY2Vzc0Rwb3BOb25jZSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyhpbnB1dCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnICYmIGlucHV0Lmxlbmd0aCAhPT0gMDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRGlzY292ZXJ5UmVzcG9uc2UoZXhwZWN0ZWRJc3N1ZXJJZGVudGlmaWVyLCByZXNwb25zZSkge1xuICAgIGlmICghKGV4cGVjdGVkSXNzdWVySWRlbnRpZmllciBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHBlY3RlZElzc3VlclwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMJyk7XG4gICAgfVxuICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBBdXRob3JpemF0aW9uIFNlcnZlciBNZXRhZGF0YSByZXNwb25zZScpO1xuICAgIH1cbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIFwicmVzcG9uc2VcIiBib2R5IGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24uaXNzdWVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImlzc3VlclwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChuZXcgVVJMKGpzb24uaXNzdWVyKS5ocmVmICE9PSBleHBlY3RlZElzc3VlcklkZW50aWZpZXIuaHJlZikge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImlzc3VlclwiIGRvZXMgbm90IG1hdGNoIFwiZXhwZWN0ZWRJc3N1ZXJcIicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKCkge1xuICAgIHJldHVybiBiNjR1KGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21Db2RlVmVyaWZpZXIoKSB7XG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21TdGF0ZSgpIHtcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbU5vbmNlKCkge1xuICAgIHJldHVybiByYW5kb21CeXRlcygpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZVBLQ0VDb2RlQ2hhbGxlbmdlKGNvZGVWZXJpZmllcikge1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoY29kZVZlcmlmaWVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNvZGVWZXJpZmllclwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgYnVmKGNvZGVWZXJpZmllcikpKTtcbn1cbmZ1bmN0aW9uIGdldEtleUFuZEtpZChpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENyeXB0b0tleSkge1xuICAgICAgICByZXR1cm4geyBrZXk6IGlucHV0IH07XG4gICAgfVxuICAgIGlmICghKGlucHV0Py5rZXkgaW5zdGFuY2VvZiBDcnlwdG9LZXkpKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKGlucHV0LmtpZCAhPT0gdW5kZWZpbmVkICYmICF2YWxpZGF0ZVN0cmluZyhpbnB1dC5raWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wia2lkXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHsga2V5OiBpbnB1dC5rZXksIGtpZDogaW5wdXQua2lkIH07XG59XG5mdW5jdGlvbiBmb3JtVXJsRW5jb2RlKHRva2VuKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh0b2tlbikucmVwbGFjZSgvJTIwL2csICcrJyk7XG59XG5mdW5jdGlvbiBjbGllbnRTZWNyZXRCYXNpYyhjbGllbnRJZCwgY2xpZW50U2VjcmV0KSB7XG4gICAgY29uc3QgdXNlcm5hbWUgPSBmb3JtVXJsRW5jb2RlKGNsaWVudElkKTtcbiAgICBjb25zdCBwYXNzd29yZCA9IGZvcm1VcmxFbmNvZGUoY2xpZW50U2VjcmV0KTtcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IGJ0b2EoYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YCk7XG4gICAgcmV0dXJuIGBCYXNpYyAke2NyZWRlbnRpYWxzfWA7XG59XG5mdW5jdGlvbiBwc0FsZyhrZXkpIHtcbiAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0uaGFzaC5uYW1lKSB7XG4gICAgICAgIGNhc2UgJ1NIQS0yNTYnOlxuICAgICAgICAgICAgcmV0dXJuICdQUzI1Nic7XG4gICAgICAgIGNhc2UgJ1NIQS0zODQnOlxuICAgICAgICAgICAgcmV0dXJuICdQUzM4NCc7XG4gICAgICAgIGNhc2UgJ1NIQS01MTInOlxuICAgICAgICAgICAgcmV0dXJuICdQUzUxMic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgUnNhSGFzaGVkS2V5QWxnb3JpdGhtIGhhc2ggbmFtZScpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJzQWxnKGtleSkge1xuICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5oYXNoLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnU0hBLTI1Nic6XG4gICAgICAgICAgICByZXR1cm4gJ1JTMjU2JztcbiAgICAgICAgY2FzZSAnU0hBLTM4NCc6XG4gICAgICAgICAgICByZXR1cm4gJ1JTMzg0JztcbiAgICAgICAgY2FzZSAnU0hBLTUxMic6XG4gICAgICAgICAgICByZXR1cm4gJ1JTNTEyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBSc2FIYXNoZWRLZXlBbGdvcml0aG0gaGFzaCBuYW1lJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXNBbGcoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUpIHtcbiAgICAgICAgY2FzZSAnUC0yNTYnOlxuICAgICAgICAgICAgcmV0dXJuICdFUzI1Nic7XG4gICAgICAgIGNhc2UgJ1AtMzg0JzpcbiAgICAgICAgICAgIHJldHVybiAnRVMzODQnO1xuICAgICAgICBjYXNlICdQLTUyMSc6XG4gICAgICAgICAgICByZXR1cm4gJ0VTNTEyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBFY0tleUFsZ29yaXRobSBuYW1lZEN1cnZlJyk7XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5VG9Kd3Moa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnUlNBLVBTUyc6XG4gICAgICAgICAgICByZXR1cm4gcHNBbGcoa2V5KTtcbiAgICAgICAgY2FzZSAnUlNBU1NBLVBLQ1MxLXYxXzUnOlxuICAgICAgICAgICAgcmV0dXJuIHJzQWxnKGtleSk7XG4gICAgICAgIGNhc2UgJ0VDRFNBJzpcbiAgICAgICAgICAgIHJldHVybiBlc0FsZyhrZXkpO1xuICAgICAgICBjYXNlICdFZDI1NTE5JzpcbiAgICAgICAgY2FzZSAnRWQ0NDgnOlxuICAgICAgICAgICAgcmV0dXJuICdFZERTQSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgQ3J5cHRvS2V5IGFsZ29yaXRobSBuYW1lJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q2xvY2tTa2V3KGNsaWVudCkge1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY2xpZW50W2Nsb2NrU2tld10pKSB7XG4gICAgICAgIHJldHVybiBjbGllbnRbY2xvY2tTa2V3XTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpIHtcbiAgICBjb25zdCB0b2xlcmFuY2UgPSBjbGllbnRbY2xvY2tUb2xlcmFuY2VdO1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodG9sZXJhbmNlKSAmJiBNYXRoLnNpZ24odG9sZXJhbmNlKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvbGVyYW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIDMwO1xufVxuZnVuY3Rpb24gZXBvY2hUaW1lKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbn1cbmZ1bmN0aW9uIGNsaWVudEFzc2VydGlvbihhcywgY2xpZW50KSB7XG4gICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBnZXRDbG9ja1NrZXcoY2xpZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBqdGk6IHJhbmRvbUJ5dGVzKCksXG4gICAgICAgIGF1ZDogW2FzLmlzc3VlciwgYXMudG9rZW5fZW5kcG9pbnRdLFxuICAgICAgICBleHA6IG5vdyArIDYwLFxuICAgICAgICBpYXQ6IG5vdyxcbiAgICAgICAgbmJmOiBub3csXG4gICAgICAgIGlzczogY2xpZW50LmNsaWVudF9pZCxcbiAgICAgICAgc3ViOiBjbGllbnQuY2xpZW50X2lkLFxuICAgIH07XG59XG5hc3luYyBmdW5jdGlvbiBwcml2YXRlS2V5Snd0KGFzLCBjbGllbnQsIGtleSwga2lkKSB7XG4gICAgcmV0dXJuIGp3dCh7XG4gICAgICAgIGFsZzoga2V5VG9Kd3Moa2V5KSxcbiAgICAgICAga2lkLFxuICAgIH0sIGNsaWVudEFzc2VydGlvbihhcywgY2xpZW50KSwga2V5KTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFzKGFzKSB7XG4gICAgaWYgKHR5cGVvZiBhcyAhPT0gJ29iamVjdCcgfHwgYXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhc1wiIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoYXMuaXNzdWVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLmlzc3VlclwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q2xpZW50KGNsaWVudCkge1xuICAgIGlmICh0eXBlb2YgY2xpZW50ICE9PSAnb2JqZWN0JyB8fCBjbGllbnQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjbGllbnRcIiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGNsaWVudC5jbGllbnRfaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2xpZW50LmNsaWVudF9pZFwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q2xpZW50U2VjcmV0KGNsaWVudFNlY3JldCkge1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoY2xpZW50U2VjcmV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNsaWVudC5jbGllbnRfc2VjcmV0XCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsaWVudFNlY3JldDtcbn1cbmZ1bmN0aW9uIGFzc2VydE5vQ2xpZW50UHJpdmF0ZUtleShjbGllbnRBdXRoTWV0aG9kLCBjbGllbnRQcml2YXRlS2V5KSB7XG4gICAgaWYgKGNsaWVudFByaXZhdGVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcIm9wdGlvbnMuY2xpZW50UHJpdmF0ZUtleVwiIHByb3BlcnR5IG11c3Qgbm90IGJlIHByb3ZpZGVkIHdoZW4gJHtjbGllbnRBdXRoTWV0aG9kfSBjbGllbnQgYXV0aGVudGljYXRpb24gbWV0aG9kIGlzIHVzZWQuYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Tm9DbGllbnRTZWNyZXQoY2xpZW50QXV0aE1ldGhvZCwgY2xpZW50U2VjcmV0KSB7XG4gICAgaWYgKGNsaWVudFNlY3JldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiY2xpZW50LmNsaWVudF9zZWNyZXRcIiBwcm9wZXJ0eSBtdXN0IG5vdCBiZSBwcm92aWRlZCB3aGVuICR7Y2xpZW50QXV0aE1ldGhvZH0gY2xpZW50IGF1dGhlbnRpY2F0aW9uIG1ldGhvZCBpcyB1c2VkLmApO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGNsaWVudEF1dGhlbnRpY2F0aW9uKGFzLCBjbGllbnQsIGJvZHksIGhlYWRlcnMsIGNsaWVudFByaXZhdGVLZXkpIHtcbiAgICBib2R5LmRlbGV0ZSgnY2xpZW50X3NlY3JldCcpO1xuICAgIGJvZHkuZGVsZXRlKCdjbGllbnRfYXNzZXJ0aW9uX3R5cGUnKTtcbiAgICBib2R5LmRlbGV0ZSgnY2xpZW50X2Fzc2VydGlvbicpO1xuICAgIHN3aXRjaCAoY2xpZW50LnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlICdjbGllbnRfc2VjcmV0X2Jhc2ljJzoge1xuICAgICAgICAgICAgYXNzZXJ0Tm9DbGllbnRQcml2YXRlS2V5KCdjbGllbnRfc2VjcmV0X2Jhc2ljJywgY2xpZW50UHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBoZWFkZXJzLnNldCgnYXV0aG9yaXphdGlvbicsIGNsaWVudFNlY3JldEJhc2ljKGNsaWVudC5jbGllbnRfaWQsIGFzc2VydENsaWVudFNlY3JldChjbGllbnQuY2xpZW50X3NlY3JldCkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NsaWVudF9zZWNyZXRfcG9zdCc6IHtcbiAgICAgICAgICAgIGFzc2VydE5vQ2xpZW50UHJpdmF0ZUtleSgnY2xpZW50X3NlY3JldF9wb3N0JywgY2xpZW50UHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgICAgICAgICBib2R5LnNldCgnY2xpZW50X3NlY3JldCcsIGFzc2VydENsaWVudFNlY3JldChjbGllbnQuY2xpZW50X3NlY3JldCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncHJpdmF0ZV9rZXlfand0Jzoge1xuICAgICAgICAgICAgYXNzZXJ0Tm9DbGllbnRTZWNyZXQoJ3ByaXZhdGVfa2V5X2p3dCcsIGNsaWVudC5jbGllbnRfc2VjcmV0KTtcbiAgICAgICAgICAgIGlmIChjbGllbnRQcml2YXRlS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuY2xpZW50UHJpdmF0ZUtleVwiIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBcImNsaWVudC50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZFwiIGlzIFwicHJpdmF0ZV9rZXlfand0XCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCBraWQgfSA9IGdldEtleUFuZEtpZChjbGllbnRQcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGlmICghaXNQcml2YXRlS2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMuY2xpZW50UHJpdmF0ZUtleS5rZXlcIiBtdXN0IGJlIGEgcHJpdmF0ZSBDcnlwdG9LZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICAgICAgICAgIGJvZHkuc2V0KCdjbGllbnRfYXNzZXJ0aW9uX3R5cGUnLCAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmNsaWVudC1hc3NlcnRpb24tdHlwZTpqd3QtYmVhcmVyJyk7XG4gICAgICAgICAgICBib2R5LnNldCgnY2xpZW50X2Fzc2VydGlvbicsIGF3YWl0IHByaXZhdGVLZXlKd3QoYXMsIGNsaWVudCwga2V5LCBraWQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vbmUnOiB7XG4gICAgICAgICAgICBhc3NlcnROb0NsaWVudFNlY3JldCgnbm9uZScsIGNsaWVudC5jbGllbnRfc2VjcmV0KTtcbiAgICAgICAgICAgIGFzc2VydE5vQ2xpZW50UHJpdmF0ZUtleSgnbm9uZScsIGNsaWVudFByaXZhdGVLZXkpO1xuICAgICAgICAgICAgYm9keS5zZXQoJ2NsaWVudF9pZCcsIGNsaWVudC5jbGllbnRfaWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCd1bnN1cHBvcnRlZCBjbGllbnQgdG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QnKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBqd3QoaGVhZGVyLCBjbGFpbXNTZXQsIGtleSkge1xuICAgIGlmICgha2V5LnVzYWdlcy5pbmNsdWRlcygnc2lnbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NyeXB0b0tleSBpbnN0YW5jZXMgdXNlZCBmb3Igc2lnbmluZyBhc3NlcnRpb25zIG11c3QgaW5jbHVkZSBcInNpZ25cIiBpbiB0aGVpciBcInVzYWdlc1wiJyk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0ID0gYCR7YjY0dShidWYoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSkpfS4ke2I2NHUoYnVmKEpTT04uc3RyaW5naWZ5KGNsYWltc1NldCkpKX1gO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGI2NHUoYXdhaXQgY3J5cHRvLnN1YnRsZS5zaWduKGtleVRvU3VidGxlKGtleSksIGtleSwgYnVmKGlucHV0KSkpO1xuICAgIHJldHVybiBgJHtpbnB1dH0uJHtzaWduYXR1cmV9YDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc3N1ZVJlcXVlc3RPYmplY3QoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgcHJpdmF0ZUtleSkge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICBjb25zdCB7IGtleSwga2lkIH0gPSBnZXRLZXlBbmRLaWQocHJpdmF0ZUtleSk7XG4gICAgaWYgKCFpc1ByaXZhdGVLZXkoa2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInByaXZhdGVLZXkua2V5XCIgbXVzdCBiZSBhIHByaXZhdGUgQ3J5cHRvS2V5Jyk7XG4gICAgfVxuICAgIHBhcmFtZXRlcnMuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGdldENsb2NrU2tldyhjbGllbnQpO1xuICAgIGNvbnN0IGNsYWltcyA9IHtcbiAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKHBhcmFtZXRlcnMuZW50cmllcygpKSxcbiAgICAgICAganRpOiByYW5kb21CeXRlcygpLFxuICAgICAgICBhdWQ6IGFzLmlzc3VlcixcbiAgICAgICAgZXhwOiBub3cgKyA2MCxcbiAgICAgICAgaWF0OiBub3csXG4gICAgICAgIG5iZjogbm93LFxuICAgICAgICBpc3M6IGNsaWVudC5jbGllbnRfaWQsXG4gICAgfTtcbiAgICBsZXQgcmVzb3VyY2U7XG4gICAgaWYgKHBhcmFtZXRlcnMuaGFzKCdyZXNvdXJjZScpICYmXG4gICAgICAgIChyZXNvdXJjZSA9IHBhcmFtZXRlcnMuZ2V0QWxsKCdyZXNvdXJjZScpKSAmJlxuICAgICAgICByZXNvdXJjZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNsYWltcy5yZXNvdXJjZSA9IHJlc291cmNlO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVycy5oYXMoJ2NsYWltcycpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1ldGVycy5nZXQoJ2NsYWltcycpO1xuICAgICAgICBpZiAodmFsdWUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdcImNsYWltc1wiIHBhcmFtZXRlciBtdXN0IGJlIHBhc3NlZCBhcyBhIFVURi04IGVuY29kZWQgSlNPTicpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjbGFpbXMuY2xhaW1zID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgdGhlIFwiY2xhaW1zXCIgcGFyYW1ldGVyIGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KGNsYWltcy5jbGFpbXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdcImNsYWltc1wiIHBhcmFtZXRlciBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqd3Qoe1xuICAgICAgICBhbGc6IGtleVRvSndzKGtleSksXG4gICAgICAgIHR5cDogJ29hdXRoLWF1dGh6LXJlcStqd3QnLFxuICAgICAgICBraWQsXG4gICAgfSwgY2xhaW1zLCBrZXkpO1xufVxuYXN5bmMgZnVuY3Rpb24gZHBvcFByb29mSnd0KGhlYWRlcnMsIG9wdGlvbnMsIHVybCwgaHRtLCBjbG9ja1NrZXcsIGFjY2Vzc1Rva2VuKSB7XG4gICAgY29uc3QgeyBwcml2YXRlS2V5LCBwdWJsaWNLZXksIG5vbmNlID0gZHBvcE5vbmNlcy5nZXQodXJsLm9yaWdpbikgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFpc1ByaXZhdGVLZXkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJEUG9QLnByaXZhdGVLZXlcIiBtdXN0IGJlIGEgcHJpdmF0ZSBDcnlwdG9LZXknKTtcbiAgICB9XG4gICAgaWYgKCFpc1B1YmxpY0tleShwdWJsaWNLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiRFBvUC5wdWJsaWNLZXlcIiBtdXN0IGJlIGEgcHVibGljIENyeXB0b0tleScpO1xuICAgIH1cbiAgICBpZiAobm9uY2UgIT09IHVuZGVmaW5lZCAmJiAhdmFsaWRhdGVTdHJpbmcobm9uY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiRFBvUC5ub25jZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAoIXB1YmxpY0tleS5leHRyYWN0YWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIkRQb1AucHVibGljS2V5LmV4dHJhY3RhYmxlXCIgbXVzdCBiZSB0cnVlJyk7XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IGVwb2NoVGltZSgpICsgY2xvY2tTa2V3O1xuICAgIGNvbnN0IHByb29mID0gYXdhaXQgand0KHtcbiAgICAgICAgYWxnOiBrZXlUb0p3cyhwcml2YXRlS2V5KSxcbiAgICAgICAgdHlwOiAnZHBvcCtqd3QnLFxuICAgICAgICBqd2s6IGF3YWl0IHB1YmxpY0p3ayhwdWJsaWNLZXkpLFxuICAgIH0sIHtcbiAgICAgICAgaWF0OiBub3csXG4gICAgICAgIGp0aTogcmFuZG9tQnl0ZXMoKSxcbiAgICAgICAgaHRtLFxuICAgICAgICBub25jZSxcbiAgICAgICAgaHR1OiBgJHt1cmwub3JpZ2lufSR7dXJsLnBhdGhuYW1lfWAsXG4gICAgICAgIGF0aDogYWNjZXNzVG9rZW4gPyBiNjR1KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgYnVmKGFjY2Vzc1Rva2VuKSkpIDogdW5kZWZpbmVkLFxuICAgIH0sIHByaXZhdGVLZXkpO1xuICAgIGhlYWRlcnMuc2V0KCdkcG9wJywgcHJvb2YpO1xufVxubGV0IGp3a0NhY2hlO1xuYXN5bmMgZnVuY3Rpb24gcHVibGljSndrKGtleSkge1xuICAgIGp3a0NhY2hlIHx8IChqd2tDYWNoZSA9IG5ldyBXZWFrTWFwKCkpO1xuICAgIGlmIChqd2tDYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gandrQ2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHsga3R5LCBlLCBuLCB4LCB5LCBjcnYgfSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdqd2snLCBrZXkpO1xuICAgIGNvbnN0IGp3ayA9IHsga3R5LCBlLCBuLCB4LCB5LCBjcnYgfTtcbiAgICBqd2tDYWNoZS5zZXQoa2V5LCBqd2spO1xuICAgIHJldHVybiBqd2s7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHVzaGVkQXV0aG9yaXphdGlvblJlcXVlc3QoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAodHlwZW9mIGFzLnB1c2hlZF9hdXRob3JpemF0aW9uX3JlcXVlc3RfZW5kcG9pbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXMucHVzaGVkX2F1dGhvcml6YXRpb25fcmVxdWVzdF9lbmRwb2ludFwiIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChhcy5wdXNoZWRfYXV0aG9yaXphdGlvbl9yZXF1ZXN0X2VuZHBvaW50KTtcbiAgICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICBib2R5LnNldCgnY2xpZW50X2lkJywgY2xpZW50LmNsaWVudF9pZCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHByZXBhcmVIZWFkZXJzKG9wdGlvbnM/LmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGlmIChvcHRpb25zPy5EUG9QICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgZHBvcFByb29mSnd0KGhlYWRlcnMsIG9wdGlvbnMuRFBvUCwgdXJsLCAnUE9TVCcsIGdldENsb2NrU2tldyhjbGllbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsICdQT1NUJywgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc09BdXRoMkVycm9yKGlucHV0KSB7XG4gICAgY29uc3QgdmFsdWUgPSBpbnB1dDtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5lcnJvciAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gdW5xdW90ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gMiAmJiB2YWx1ZVswXSA9PT0gJ1wiJyAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJ1wiJykge1xuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBTUExJVF9SRUdFWFAgPSAvKCg/Oix8LCApP1swLTlhLXpBLVohIyQlJicqKy0uXl9gfH5dKz0pLztcbmNvbnN0IFNDSEVNRVNfUkVHRVhQID0gLyg/Ol58LCA/KShbMC05YS16QS1aISMkJSYnKitcXC0uXl9gfH5dKykoPz0kfFsgLF0pL2c7XG5mdW5jdGlvbiB3d3dBdXRoKHNjaGVtZSwgcGFyYW1zKSB7XG4gICAgY29uc3QgYXJyID0gcGFyYW1zLnNwbGl0KFNQTElUX1JFR0VYUCkuc2xpY2UoMSk7XG4gICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IHNjaGVtZTogc2NoZW1lLnRvTG93ZXJDYXNlKCksIHBhcmFtZXRlcnM6IHt9IH07XG4gICAgfVxuICAgIGFyclthcnIubGVuZ3RoIC0gMV0gPSBhcnJbYXJyLmxlbmd0aCAtIDFdLnJlcGxhY2UoLywkLywgJycpO1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBpZHggPSBpO1xuICAgICAgICBpZiAoYXJyW2lkeF1bMF0gPT09ICdcIicpIHtcbiAgICAgICAgICAgIHdoaWxlIChhcnJbaWR4XS5zbGljZSgtMSkgIT09ICdcIicgJiYgKytpIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFycltpZHhdICs9IGFycltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSBhcnJbaWR4IC0gMV0ucmVwbGFjZSgvXig/OiwgPyl8PSQvZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHBhcmFtZXRlcnNba2V5XSA9IHVucXVvdGUoYXJyW2lkeF0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6IHNjaGVtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBwYXJhbWV0ZXJzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VXd3dBdXRoZW50aWNhdGVDaGFsbGVuZ2VzKHJlc3BvbnNlKSB7XG4gICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5oZWFkZXJzLmhhcygnd3d3LWF1dGhlbnRpY2F0ZScpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd3d3ctYXV0aGVudGljYXRlJyk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCB7IDE6IHNjaGVtZSwgaW5kZXggfSBvZiBoZWFkZXIubWF0Y2hBbGwoU0NIRU1FU19SRUdFWFApKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtzY2hlbWUsIGluZGV4XSk7XG4gICAgfVxuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjaGFsbGVuZ2VzID0gcmVzdWx0Lm1hcCgoW3NjaGVtZSwgaW5kZXhPZl0sIGksIG90aGVycykgPT4ge1xuICAgICAgICBjb25zdCBuZXh0ID0gb3RoZXJzW2kgKyAxXTtcbiAgICAgICAgbGV0IHBhcmFtZXRlcnM7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzID0gaGVhZGVyLnNsaWNlKGluZGV4T2YsIG5leHRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1ldGVycyA9IGhlYWRlci5zbGljZShpbmRleE9mKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3d3QXV0aChzY2hlbWUsIHBhcmFtZXRlcnMpO1xuICAgIH0pO1xuICAgIHJldHVybiBjaGFsbGVuZ2VzO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NQdXNoZWRBdXRob3JpemF0aW9uUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAxKSB7XG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmICgoZXJyID0gYXdhaXQgaGFuZGxlT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBQdXNoZWQgQXV0aG9yaXphdGlvbiBSZXF1ZXN0IEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGxldCBqc29uO1xuICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdmYWlsZWQgdG8gcGFyc2UgXCJyZXNwb25zZVwiIGJvZHkgYXMgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcoanNvbi5yZXF1ZXN0X3VyaSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJyZXF1ZXN0X3VyaVwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YganNvbi5leHBpcmVzX2luICE9PSAnbnVtYmVyJyB8fCBqc29uLmV4cGlyZXNfaW4gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImV4cGlyZXNfaW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb3RlY3RlZFJlc291cmNlUmVxdWVzdChhY2Nlc3NUb2tlbiwgbWV0aG9kLCB1cmwsIGhlYWRlcnMsIGJvZHksIG9wdGlvbnMpIHtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGFjY2Vzc1Rva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFjY2Vzc1Rva2VuXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCEodXJsIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInVybFwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMJyk7XG4gICAgfVxuICAgIGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhoZWFkZXJzKTtcbiAgICBpZiAob3B0aW9ucz8uRFBvUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhdXRob3JpemF0aW9uJywgYEJlYXJlciAke2FjY2Vzc1Rva2VufWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXdhaXQgZHBvcFByb29mSnd0KGhlYWRlcnMsIG9wdGlvbnMuRFBvUCwgdXJsLCAnR0VUJywgZ2V0Q2xvY2tTa2V3KHsgW2Nsb2NrU2tld106IG9wdGlvbnM/LmNsb2NrU2tldyB9KSwgYWNjZXNzVG9rZW4pO1xuICAgICAgICBoZWFkZXJzLnNldCgnYXV0aG9yaXphdGlvbicsIGBEUG9QICR7YWNjZXNzVG9rZW59YCk7XG4gICAgfVxuICAgIHJldHVybiBmZXRjaCh1cmwuaHJlZiwge1xuICAgICAgICBib2R5LFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHJlZGlyZWN0OiAnbWFudWFsJyxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwgPyBzaWduYWwob3B0aW9ucy5zaWduYWwpIDogbnVsbCxcbiAgICB9KS50aGVuKHByb2Nlc3NEcG9wTm9uY2UpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVzZXJJbmZvUmVxdWVzdChhcywgY2xpZW50LCBhY2Nlc3NUb2tlbiwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAodHlwZW9mIGFzLnVzZXJpbmZvX2VuZHBvaW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLnVzZXJpbmZvX2VuZHBvaW50XCIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGFzLnVzZXJpbmZvX2VuZHBvaW50KTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaWYgKGNsaWVudC51c2VyaW5mb19zaWduZWRfcmVzcG9uc2VfYWxnKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vand0Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qd3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3RlY3RlZFJlc291cmNlUmVxdWVzdChhY2Nlc3NUb2tlbiwgJ0dFVCcsIHVybCwgaGVhZGVycywgbnVsbCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBjbG9ja1NrZXc6IGdldENsb2NrU2tldyhjbGllbnQpLFxuICAgIH0pO1xufVxubGV0IGp3a3NDYWNoZTtcbmFzeW5jIGZ1bmN0aW9uIGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpKGFzLCBvcHRpb25zLCBoZWFkZXIpIHtcbiAgICBjb25zdCB7IGFsZywga2lkIH0gPSBoZWFkZXI7XG4gICAgY2hlY2tTdXBwb3J0ZWRKd3NBbGcoYWxnKTtcbiAgICBsZXQgandrcztcbiAgICBsZXQgYWdlO1xuICAgIGp3a3NDYWNoZSB8fCAoandrc0NhY2hlID0gbmV3IFdlYWtNYXAoKSk7XG4gICAgaWYgKGp3a3NDYWNoZS5oYXMoYXMpKSB7XG4gICAgICAgIDtcbiAgICAgICAgKHsgandrcywgYWdlIH0gPSBqd2tzQ2FjaGUuZ2V0KGFzKSk7XG4gICAgICAgIGlmIChhZ2UgPj0gMzAwKSB7XG4gICAgICAgICAgICBqd2tzQ2FjaGUuZGVsZXRlKGFzKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaShhcywgb3B0aW9ucywgaGVhZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgandrcyA9IGF3YWl0IGp3a3NSZXF1ZXN0KGFzLCBvcHRpb25zKS50aGVuKHByb2Nlc3NKd2tzUmVzcG9uc2UpO1xuICAgICAgICBhZ2UgPSAwO1xuICAgICAgICBqd2tzQ2FjaGUuc2V0KGFzLCB7XG4gICAgICAgICAgICBqd2tzLFxuICAgICAgICAgICAgaWF0OiBlcG9jaFRpbWUoKSxcbiAgICAgICAgICAgIGdldCBhZ2UoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVwb2NoVGltZSgpIC0gdGhpcy5pYXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGt0eTtcbiAgICBzd2l0Y2ggKGFsZy5zbGljZSgwLCAyKSkge1xuICAgICAgICBjYXNlICdSUyc6XG4gICAgICAgIGNhc2UgJ1BTJzpcbiAgICAgICAgICAgIGt0eSA9ICdSU0EnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0VTJzpcbiAgICAgICAgICAgIGt0eSA9ICdFQyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRWQnOlxuICAgICAgICAgICAga3R5ID0gJ09LUCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBqd2tzLmtleXMuZmlsdGVyKChqd2spID0+IHtcbiAgICAgICAgaWYgKGp3ay5rdHkgIT09IGt0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChraWQgIT09IHVuZGVmaW5lZCAmJiBraWQgIT09IGp3ay5raWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoandrLmFsZyAhPT0gdW5kZWZpbmVkICYmIGFsZyAhPT0gandrLmFsZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqd2sudXNlICE9PSB1bmRlZmluZWQgJiYgandrLnVzZSAhPT0gJ3NpZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoandrLmtleV9vcHM/LmluY2x1ZGVzKCd2ZXJpZnknKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgYWxnID09PSAnRVMyNTYnICYmIGp3ay5jcnYgIT09ICdQLTI1Nic6XG4gICAgICAgICAgICBjYXNlIGFsZyA9PT0gJ0VTMzg0JyAmJiBqd2suY3J2ICE9PSAnUC0zODQnOlxuICAgICAgICAgICAgY2FzZSBhbGcgPT09ICdFUzUxMicgJiYgandrLmNydiAhPT0gJ1AtNTIxJzpcbiAgICAgICAgICAgIGNhc2UgYWxnID09PSAnRWREU0EnICYmICEoandrLmNydiA9PT0gJ0VkMjU1MTknIHx8IGp3ay5jcnYgPT09ICdFZDQ0OCcpOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBjb25zdCB7IDA6IGp3aywgbGVuZ3RoIH0gPSBjYW5kaWRhdGVzO1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGlmIChhZ2UgPj0gNjApIHtcbiAgICAgICAgICAgIGp3a3NDYWNoZS5kZWxldGUoYXMpO1xuICAgICAgICAgICAgcmV0dXJuIGdldFB1YmxpY1NpZ0tleUZyb21Jc3N1ZXJKd2tzVXJpKGFzLCBvcHRpb25zLCBoZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2Vycm9yIHdoZW4gc2VsZWN0aW5nIGEgSldUIHZlcmlmaWNhdGlvbiBrZXksIG5vIGFwcGxpY2FibGUga2V5cyBmb3VuZCcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZXJyb3Igd2hlbiBzZWxlY3RpbmcgYSBKV1QgdmVyaWZpY2F0aW9uIGtleSwgbXVsdGlwbGUgYXBwbGljYWJsZSBrZXlzIGZvdW5kLCBhIFwia2lkXCIgSldUIEhlYWRlciBQYXJhbWV0ZXIgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgaW1wb3J0SndrKGFsZywgandrKTtcbiAgICBpZiAoa2V5LnR5cGUgIT09ICdwdWJsaWMnKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2p3a3NfdXJpIG11c3Qgb25seSBjb250YWluIHB1YmxpYyBrZXlzJyk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG59XG5leHBvcnQgY29uc3Qgc2tpcFN1YmplY3RDaGVjayA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gZ2V0Q29udGVudFR5cGUocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpPy5zcGxpdCgnOycpWzBdO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NVc2VySW5mb1Jlc3BvbnNlKGFzLCBjbGllbnQsIGV4cGVjdGVkU3ViamVjdCwgcmVzcG9uc2UpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBpcyBub3QgYSBjb25mb3JtIFVzZXJJbmZvIEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGxldCBqc29uO1xuICAgIGlmIChnZXRDb250ZW50VHlwZShyZXNwb25zZSkgPT09ICdhcHBsaWNhdGlvbi9qd3QnKSB7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICBjb25zdCB7IGNsYWltcyB9ID0gYXdhaXQgdmFsaWRhdGVKd3QoYXdhaXQgcmVzcG9uc2UudGV4dCgpLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC51c2VyaW5mb19zaWduZWRfcmVzcG9uc2VfYWxnLCBhcy51c2VyaW5mb19zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkKSwgbm9TaWduYXR1cmVDaGVjaywgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCkpXG4gICAgICAgICAgICAudGhlbih2YWxpZGF0ZU9wdGlvbmFsQXVkaWVuY2UuYmluZCh1bmRlZmluZWQsIGNsaWVudC5jbGllbnRfaWQpKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVPcHRpb25hbElzc3Vlci5iaW5kKHVuZGVmaW5lZCwgYXMuaXNzdWVyKSk7XG4gICAgICAgIGpzb24gPSBjbGFpbXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoY2xpZW50LnVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ0pXVCBVc2VySW5mbyBSZXNwb25zZSBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24uc3ViKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcInN1YlwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHN3aXRjaCAoZXhwZWN0ZWRTdWJqZWN0KSB7XG4gICAgICAgIGNhc2Ugc2tpcFN1YmplY3RDaGVjazpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhleHBlY3RlZFN1YmplY3QpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJleHBlY3RlZFN1YmplY3RcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24uc3ViICE9PSBleHBlY3RlZFN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIFwicmVzcG9uc2VcIiBib2R5IFwic3ViXCIgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5hc3luYyBmdW5jdGlvbiBhdXRoZW50aWNhdGVkUmVxdWVzdChhcywgY2xpZW50LCBtZXRob2QsIHVybCwgYm9keSwgaGVhZGVycywgb3B0aW9ucykge1xuICAgIGF3YWl0IGNsaWVudEF1dGhlbnRpY2F0aW9uKGFzLCBjbGllbnQsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnM/LmNsaWVudFByaXZhdGVLZXkpO1xuICAgIGhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICByZXR1cm4gZmV0Y2godXJsLmhyZWYsIHtcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsID8gc2lnbmFsKG9wdGlvbnMuc2lnbmFsKSA6IG51bGwsXG4gICAgfSkudGhlbihwcm9jZXNzRHBvcE5vbmNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsIGdyYW50VHlwZSwgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgYXMudG9rZW5fZW5kcG9pbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXMudG9rZW5fZW5kcG9pbnRcIiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYXMudG9rZW5fZW5kcG9pbnQpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdncmFudF90eXBlJywgZ3JhbnRUeXBlKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgaWYgKG9wdGlvbnM/LkRQb1AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBkcG9wUHJvb2ZKd3QoaGVhZGVycywgb3B0aW9ucy5EUG9QLCB1cmwsICdQT1NUJywgZ2V0Q2xvY2tTa2V3KGNsaWVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgJ1BPU1QnLCB1cmwsIHBhcmFtZXRlcnMsIGhlYWRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hUb2tlbkdyYW50UmVxdWVzdChhcywgY2xpZW50LCByZWZyZXNoVG9rZW4sIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhyZWZyZXNoVG9rZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVmcmVzaFRva2VuXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdyZWZyZXNoX3Rva2VuJywgcmVmcmVzaFRva2VuKTtcbiAgICByZXR1cm4gdG9rZW5FbmRwb2ludFJlcXVlc3QoYXMsIGNsaWVudCwgJ3JlZnJlc2hfdG9rZW4nLCBwYXJhbWV0ZXJzLCBvcHRpb25zKTtcbn1cbmNvbnN0IGlkVG9rZW5DbGFpbXMgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbGlkYXRlZElkVG9rZW5DbGFpbXMocmVmKSB7XG4gICAgaWYgKCFyZWYuaWRfdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY2xhaW1zID0gaWRUb2tlbkNsYWltcy5nZXQocmVmKTtcbiAgICBpZiAoIWNsYWltcykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlZlwiIHdhcyBhbHJlYWR5IGdhcmJhZ2UgY29sbGVjdGVkIG9yIGRpZCBub3QgcmVzb2x2ZSBmcm9tIHRoZSBwcm9wZXIgc291cmNlcycpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhaW1zO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlLCBpZ25vcmVJZFRva2VuID0gZmFsc2UsIGlnbm9yZVJlZnJlc2hUb2tlbiA9IGZhbHNlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAoKGVyciA9IGF3YWl0IGhhbmRsZU9BdXRoQm9keUVycm9yKHJlc3BvbnNlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gVG9rZW4gRW5kcG9pbnQgcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLmFjY2Vzc190b2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJhY2Nlc3NfdG9rZW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24udG9rZW5fdHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJ0b2tlbl90eXBlXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAganNvbi50b2tlbl90eXBlID0ganNvbi50b2tlbl90eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGpzb24udG9rZW5fdHlwZSAhPT0gJ2Rwb3AnICYmIGpzb24udG9rZW5fdHlwZSAhPT0gJ2JlYXJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoJ3Vuc3VwcG9ydGVkIGB0b2tlbl90eXBlYCB2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAoanNvbi5leHBpcmVzX2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKHR5cGVvZiBqc29uLmV4cGlyZXNfaW4gIT09ICdudW1iZXInIHx8IGpzb24uZXhwaXJlc19pbiA8PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImV4cGlyZXNfaW5cIiBwcm9wZXJ0eSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmICghaWdub3JlUmVmcmVzaFRva2VuICYmXG4gICAgICAgIGpzb24ucmVmcmVzaF90b2tlbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICF2YWxpZGF0ZVN0cmluZyhqc29uLnJlZnJlc2hfdG9rZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwicmVmcmVzaF90b2tlblwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChqc29uLnNjb3BlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGpzb24uc2NvcGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwic2NvcGVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICghaWdub3JlSWRUb2tlbikge1xuICAgICAgICBpZiAoanNvbi5pZF90b2tlbiAhPT0gdW5kZWZpbmVkICYmICF2YWxpZGF0ZVN0cmluZyhqc29uLmlkX3Rva2VuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJpZF90b2tlblwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24uaWRfdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2xhaW1zIH0gPSBhd2FpdCB2YWxpZGF0ZUp3dChqc29uLmlkX3Rva2VuLCBjaGVja1NpZ25pbmdBbGdvcml0aG0uYmluZCh1bmRlZmluZWQsIGNsaWVudC5pZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnLCBhcy5pZF90b2tlbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkKSwgbm9TaWduYXR1cmVDaGVjaywgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCkpXG4gICAgICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgWydhdWQnLCAnZXhwJywgJ2lhdCcsICdpc3MnLCAnc3ViJ10pKVxuICAgICAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcy5pc3N1ZXIpKVxuICAgICAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlQXVkaWVuY2UuYmluZCh1bmRlZmluZWQsIGNsaWVudC5jbGllbnRfaWQpKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNsYWltcy5hdWQpICYmIGNsYWltcy5hdWQubGVuZ3RoICE9PSAxICYmIGNsYWltcy5henAgIT09IGNsaWVudC5jbGllbnRfaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIElEIFRva2VuIFwiYXpwXCIgKGF1dGhvcml6ZWQgcGFydHkpIGNsYWltIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpZW50LnJlcXVpcmVfYXV0aF90aW1lICYmIHR5cGVvZiBjbGFpbXMuYXV0aF90aW1lICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJhdXRoX3RpbWVcIiAoYXV0aGVudGljYXRpb24gdGltZSkgY2xhaW0gdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkVG9rZW5DbGFpbXMuc2V0KGpzb24sIGNsYWltcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1JlZnJlc2hUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbmFsQXVkaWVuY2UoZXhwZWN0ZWQsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQuY2xhaW1zLmF1ZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUF1ZGllbmNlKGV4cGVjdGVkLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBdWRpZW5jZShleHBlY3RlZCwgcmVzdWx0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0LmNsYWltcy5hdWQpKSB7XG4gICAgICAgIGlmICghcmVzdWx0LmNsYWltcy5hdWQuaW5jbHVkZXMoZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImF1ZFwiIChhdWRpZW5jZSkgY2xhaW0gdmFsdWUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQuY2xhaW1zLmF1ZCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhdWRcIiAoYXVkaWVuY2UpIGNsYWltIHZhbHVlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbmFsSXNzdWVyKGV4cGVjdGVkLCByZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LmNsYWltcy5pc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVJc3N1ZXIoZXhwZWN0ZWQsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUlzc3VlcihleHBlY3RlZCwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5jbGFpbXMuaXNzICE9PSBleHBlY3RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImlzc1wiIChpc3N1ZXIpIGNsYWltIHZhbHVlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBicmFuZGVkID0gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uIGJyYW5kKHNlYXJjaFBhcmFtcykge1xuICAgIGJyYW5kZWQuYWRkKHNlYXJjaFBhcmFtcyk7XG4gICAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhdXRob3JpemF0aW9uQ29kZUdyYW50UmVxdWVzdChhcywgY2xpZW50LCBjYWxsYmFja1BhcmFtZXRlcnMsIHJlZGlyZWN0VXJpLCBjb2RlVmVyaWZpZXIsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCFicmFuZGVkLmhhcyhjYWxsYmFja1BhcmFtZXRlcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tQYXJhbWV0ZXJzXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkxTZWFyY2hQYXJhbXMgb2J0YWluZWQgZnJvbSBcInZhbGlkYXRlQXV0aFJlc3BvbnNlKClcIiwgb3IgXCJ2YWxpZGF0ZUp3dEF1dGhSZXNwb25zZSgpJyk7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcocmVkaXJlY3RVcmkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVkaXJlY3RVcmlcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGNvZGVWZXJpZmllcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjb2RlVmVyaWZpZXJcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCBjb2RlID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKGNhbGxiYWNrUGFyYW1ldGVycywgJ2NvZGUnKTtcbiAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnbm8gYXV0aG9yaXphdGlvbiBjb2RlIGluIFwiY2FsbGJhY2tQYXJhbWV0ZXJzXCInKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdyZWRpcmVjdF91cmknLCByZWRpcmVjdFVyaSk7XG4gICAgcGFyYW1ldGVycy5zZXQoJ2NvZGVfdmVyaWZpZXInLCBjb2RlVmVyaWZpZXIpO1xuICAgIHBhcmFtZXRlcnMuc2V0KCdjb2RlJywgY29kZSk7XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsICdhdXRob3JpemF0aW9uX2NvZGUnLCBwYXJhbWV0ZXJzLCBvcHRpb25zKTtcbn1cbmNvbnN0IGNsYWltTmFtZXMgPSB7XG4gICAgYXVkOiAnYXVkaWVuY2UnLFxuICAgIGV4cDogJ2V4cGlyYXRpb24gdGltZScsXG4gICAgaWF0OiAnaXNzdWVkIGF0JyxcbiAgICBpc3M6ICdpc3N1ZXInLFxuICAgIHN1YjogJ3N1YmplY3QnLFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJlc2VuY2UocmVxdWlyZWQsIHJlc3VsdCkge1xuICAgIGZvciAoY29uc3QgY2xhaW0gb2YgcmVxdWlyZWQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5jbGFpbXNbY2xhaW1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoYEpXVCBcIiR7Y2xhaW19XCIgKCR7Y2xhaW1OYW1lc1tjbGFpbV19KSBjbGFpbSBtaXNzaW5nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjb25zdCBleHBlY3ROb05vbmNlID0gU3ltYm9sKCk7XG5leHBvcnQgY29uc3Qgc2tpcEF1dGhUaW1lQ2hlY2sgPSBTeW1ib2woKTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVPcGVuSURSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgZXhwZWN0ZWROb25jZSwgbWF4QWdlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKTtcbiAgICBpZiAoaXNPQXV0aDJFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICghdmFsaWRhdGVTdHJpbmcocmVzdWx0LmlkX3Rva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImlkX3Rva2VuXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgbWF4QWdlID8/IChtYXhBZ2UgPSBjbGllbnQuZGVmYXVsdF9tYXhfYWdlID8/IHNraXBBdXRoVGltZUNoZWNrKTtcbiAgICBjb25zdCBjbGFpbXMgPSBnZXRWYWxpZGF0ZWRJZFRva2VuQ2xhaW1zKHJlc3VsdCk7XG4gICAgaWYgKChjbGllbnQucmVxdWlyZV9hdXRoX3RpbWUgfHwgbWF4QWdlICE9PSBza2lwQXV0aFRpbWVDaGVjaykgJiZcbiAgICAgICAgY2xhaW1zLmF1dGhfdGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ0lEIFRva2VuIFwiYXV0aF90aW1lXCIgKGF1dGhlbnRpY2F0aW9uIHRpbWUpIGNsYWltIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgaWYgKG1heEFnZSAhPT0gc2tpcEF1dGhUaW1lQ2hlY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXhBZ2UgIT09ICdudW1iZXInIHx8IG1heEFnZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5tYXhfYWdlXCIgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBlcG9jaFRpbWUoKSArIGdldENsb2NrU2tldyhjbGllbnQpO1xuICAgICAgICBjb25zdCB0b2xlcmFuY2UgPSBnZXRDbG9ja1RvbGVyYW5jZShjbGllbnQpO1xuICAgICAgICBpZiAoY2xhaW1zLmF1dGhfdGltZSArIG1heEFnZSA8IG5vdyAtIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndG9vIG11Y2ggdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBFbmQtVXNlciBhdXRoZW50aWNhdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoZXhwZWN0ZWROb25jZSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSBleHBlY3ROb05vbmNlOlxuICAgICAgICAgICAgaWYgKGNsYWltcy5ub25jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBJRCBUb2tlbiBcIm5vbmNlXCIgY2xhaW0gdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhleHBlY3RlZE5vbmNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXhwZWN0ZWROb25jZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xhaW1zLm5vbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdJRCBUb2tlbiBcIm5vbmNlXCIgY2xhaW0gbWlzc2luZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsYWltcy5ub25jZSAhPT0gZXhwZWN0ZWROb25jZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSUQgVG9rZW4gXCJub25jZVwiIGNsYWltIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT0F1dGgyUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UsIHRydWUpO1xuICAgIGlmIChpc09BdXRoMkVycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5pZF90b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0LmlkX3Rva2VuID09PSAnc3RyaW5nJyAmJiByZXN1bHQuaWRfdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdVbmV4cGVjdGVkIElEIFRva2VuIHJldHVybmVkLCB1c2UgcHJvY2Vzc0F1dGhvcml6YXRpb25Db2RlT3BlbklEUmVzcG9uc2UoKSBmb3IgT3BlbklEIENvbm5lY3QgY2FsbGJhY2sgcHJvY2Vzc2luZycpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSByZXN1bHQuaWRfdG9rZW47XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaGVja0p3dFR5cGUoZXhwZWN0ZWQsIHJlc3VsdCkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0LmhlYWRlci50eXAgIT09ICdzdHJpbmcnIHx8IG5vcm1hbGl6ZVR5cChyZXN1bHQuaGVhZGVyLnR5cCkgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwidHlwXCIgaGVhZGVyIHBhcmFtZXRlciB2YWx1ZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsaWVudENyZWRlbnRpYWxzR3JhbnRSZXF1ZXN0KGFzLCBjbGllbnQsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgcmV0dXJuIHRva2VuRW5kcG9pbnRSZXF1ZXN0KGFzLCBjbGllbnQsICdjbGllbnRfY3JlZGVudGlhbHMnLCBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2xpZW50Q3JlZGVudGlhbHNSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb2Nlc3NHZW5lcmljQWNjZXNzVG9rZW5SZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgaWYgKGlzT0F1dGgyRXJyb3IocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJldm9jYXRpb25SZXF1ZXN0KGFzLCBjbGllbnQsIHRva2VuLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghdmFsaWRhdGVTdHJpbmcodG9rZW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widG9rZW5cIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFzLnJldm9jYXRpb25fZW5kcG9pbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXMucmV2b2NhdGlvbl9lbmRwb2ludFwiIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChhcy5yZXZvY2F0aW9uX2VuZHBvaW50KTtcbiAgICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zPy5hZGRpdGlvbmFsUGFyYW1ldGVycyk7XG4gICAgYm9keS5zZXQoJ3Rva2VuJywgdG9rZW4pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLmRlbGV0ZSgnYWNjZXB0Jyk7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsICdQT1NUJywgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzUmV2b2NhdGlvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmICgoZXJyID0gYXdhaXQgaGFuZGxlT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBSZXZvY2F0aW9uIEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBib2R5IGhhcyBiZWVuIHVzZWQgYWxyZWFkeScpO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbnRyb3NwZWN0aW9uUmVxdWVzdChhcywgY2xpZW50LCB0b2tlbiwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKHRva2VuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRva2VuXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcy5pbnRyb3NwZWN0aW9uX2VuZHBvaW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLmludHJvc3BlY3Rpb25fZW5kcG9pbnRcIiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYXMuaW50cm9zcGVjdGlvbl9lbmRwb2ludCk7XG4gICAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucz8uYWRkaXRpb25hbFBhcmFtZXRlcnMpO1xuICAgIGJvZHkuc2V0KCd0b2tlbicsIHRva2VuKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaWYgKG9wdGlvbnM/LnJlcXVlc3RKd3RSZXNwb25zZSA/PyBjbGllbnQuaW50cm9zcGVjdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vdG9rZW4taW50cm9zcGVjdGlvbitqd3QnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aGVudGljYXRlZFJlcXVlc3QoYXMsIGNsaWVudCwgJ1BPU1QnLCB1cmwsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NJbnRyb3NwZWN0aW9uUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpIHtcbiAgICBhc3NlcnRBcyhhcyk7XG4gICAgYXNzZXJ0Q2xpZW50KGNsaWVudCk7XG4gICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJyZXNwb25zZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVzcG9uc2UnKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIGxldCBlcnI7XG4gICAgICAgIGlmICgoZXJyID0gYXdhaXQgaGFuZGxlT0F1dGhCb2R5RXJyb3IocmVzcG9uc2UpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgaXMgbm90IGEgY29uZm9ybSBJbnRyb3NwZWN0aW9uIEVuZHBvaW50IHJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGxldCBqc29uO1xuICAgIGlmIChnZXRDb250ZW50VHlwZShyZXNwb25zZSkgPT09ICdhcHBsaWNhdGlvbi90b2tlbi1pbnRyb3NwZWN0aW9uK2p3dCcpIHtcbiAgICAgICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIGNvbnN0IHsgY2xhaW1zIH0gPSBhd2FpdCB2YWxpZGF0ZUp3dChhd2FpdCByZXNwb25zZS50ZXh0KCksIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmludHJvc3BlY3Rpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMuaW50cm9zcGVjdGlvbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkKSwgbm9TaWduYXR1cmVDaGVjaywgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCkpXG4gICAgICAgICAgICAudGhlbihjaGVja0p3dFR5cGUuYmluZCh1bmRlZmluZWQsICd0b2tlbi1pbnRyb3NwZWN0aW9uK2p3dCcpKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVQcmVzZW5jZS5iaW5kKHVuZGVmaW5lZCwgWydhdWQnLCAnaWF0JywgJ2lzcyddKSlcbiAgICAgICAgICAgIC50aGVuKHZhbGlkYXRlSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcy5pc3N1ZXIpKVxuICAgICAgICAgICAgLnRoZW4odmFsaWRhdGVBdWRpZW5jZS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmNsaWVudF9pZCkpO1xuICAgICAgICBqc29uID0gY2xhaW1zLnRva2VuX2ludHJvc3BlY3Rpb247XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCdKV1QgXCJ0b2tlbl9pbnRyb3NwZWN0aW9uXCIgY2xhaW0gbXVzdCBiZSBhIEpTT04gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb24uYWN0aXZlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJhY3RpdmVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgYm9vbGVhbicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGp3a3NSZXF1ZXN0KGFzLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGlmICh0eXBlb2YgYXMuandrc191cmkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXMuandrc191cmlcIiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYXMuandrc191cmkpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwcmVwYXJlSGVhZGVycyhvcHRpb25zPy5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICBoZWFkZXJzLmFwcGVuZCgnYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2p3ay1zZXQranNvbicpO1xuICAgIHJldHVybiBmZXRjaCh1cmwuaHJlZiwge1xuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsID8gc2lnbmFsKG9wdGlvbnMuc2lnbmFsKSA6IG51bGwsXG4gICAgfSkudGhlbihwcm9jZXNzRHBvcE5vbmNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NKd2tzUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInJlc3BvbnNlXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBSZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gSlNPTiBXZWIgS2V5IFNldCByZXNwb25zZScpO1xuICAgIH1cbiAgICBhc3NlcnRSZWFkYWJsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIFwicmVzcG9uc2VcIiBib2R5IGFzIEpTT04nLCB7IGNhdXNlIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzSnNvbk9iamVjdChqc29uKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBtdXN0IGJlIGEgdG9wIGxldmVsIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbi5rZXlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImtleXNcIiBwcm9wZXJ0eSBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkucHJvdG90eXBlLmV2ZXJ5LmNhbGwoanNvbi5rZXlzLCBpc0pzb25PYmplY3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwia2V5c1wiIHByb3BlcnR5IG1lbWJlcnMgbXVzdCBiZSBKV0sgZm9ybWF0dGVkIG9iamVjdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVPQXV0aEJvZHlFcnJvcihyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPiAzOTkgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgIGFzc2VydFJlYWRhYmxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChpc0pzb25PYmplY3QoanNvbikgJiYgdHlwZW9mIGpzb24uZXJyb3IgPT09ICdzdHJpbmcnICYmIGpzb24uZXJyb3IubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uZXJyb3JfZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YganNvbi5lcnJvcl9kZXNjcmlwdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb24uZXJyb3JfZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqc29uLmVycm9yX3VyaSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBqc29uLmVycm9yX3VyaSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb24uZXJyb3JfdXJpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoanNvbi5hbGdzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGpzb24uYWxncyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb24uYWxncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uc2NvcGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YganNvbi5zY29wZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGpzb24uc2NvcGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHsgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gY2hlY2tTdXBwb3J0ZWRKd3NBbGcoYWxnKSB7XG4gICAgaWYgKCFTVVBQT1JURURfSldTX0FMR1MuaW5jbHVkZXMoYWxnKSkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigndW5zdXBwb3J0ZWQgSldTIFwiYWxnXCIgaWRlbnRpZmllcicpO1xuICAgIH1cbiAgICByZXR1cm4gYWxnO1xufVxuZnVuY3Rpb24gY2hlY2tSc2FLZXlBbGdvcml0aG0oYWxnb3JpdGhtKSB7XG4gICAgaWYgKHR5cGVvZiBhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCAhPT0gJ251bWJlcicgfHwgYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPCAyMDQ4KSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoYCR7YWxnb3JpdGhtLm5hbWV9IG1vZHVsdXNMZW5ndGggbXVzdCBiZSBhdCBsZWFzdCAyMDQ4IGJpdHNgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlY2RzYUhhc2hOYW1lKG5hbWVkQ3VydmUpIHtcbiAgICBzd2l0Y2ggKG5hbWVkQ3VydmUpIHtcbiAgICAgICAgY2FzZSAnUC0yNTYnOlxuICAgICAgICAgICAgcmV0dXJuICdTSEEtMjU2JztcbiAgICAgICAgY2FzZSAnUC0zODQnOlxuICAgICAgICAgICAgcmV0dXJuICdTSEEtMzg0JztcbiAgICAgICAgY2FzZSAnUC01MjEnOlxuICAgICAgICAgICAgcmV0dXJuICdTSEEtNTEyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5VG9TdWJ0bGUoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnRUNEU0EnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBrZXkuYWxnb3JpdGhtLm5hbWUsXG4gICAgICAgICAgICAgICAgaGFzaDogZWNkc2FIYXNoTmFtZShrZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnUlNBLVBTUyc6IHtcbiAgICAgICAgICAgIGNoZWNrUnNhS2V5QWxnb3JpdGhtKGtleS5hbGdvcml0aG0pO1xuICAgICAgICAgICAgc3dpdGNoIChrZXkuYWxnb3JpdGhtLmhhc2gubmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NIQS0yNTYnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1NIQS0zODQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1NIQS01MTInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LmFsZ29yaXRobS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2FsdExlbmd0aDogcGFyc2VJbnQoa2V5LmFsZ29yaXRobS5oYXNoLm5hbWUuc2xpY2UoLTMpLCAxMCkgPj4gMyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1JTQVNTQS1QS0NTMS12MV81JzpcbiAgICAgICAgICAgIGNoZWNrUnNhS2V5QWxnb3JpdGhtKGtleS5hbGdvcml0aG0pO1xuICAgICAgICAgICAgcmV0dXJuIGtleS5hbGdvcml0aG0ubmFtZTtcbiAgICAgICAgY2FzZSAnRWQ0NDgnOlxuICAgICAgICBjYXNlICdFZDI1NTE5JzpcbiAgICAgICAgICAgIHJldHVybiBrZXkuYWxnb3JpdGhtLm5hbWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCk7XG59XG5jb25zdCBub1NpZ25hdHVyZUNoZWNrID0gU3ltYm9sKCk7XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUp3dChqd3MsIGNoZWNrQWxnLCBnZXRLZXksIGNsb2NrU2tldywgY2xvY2tUb2xlcmFuY2UpIHtcbiAgICBjb25zdCB7IDA6IHByb3RlY3RlZEhlYWRlciwgMTogcGF5bG9hZCwgMjogZW5jb2RlZFNpZ25hdHVyZSwgbGVuZ3RoIH0gPSBqd3Muc3BsaXQoJy4nKTtcbiAgICBpZiAobGVuZ3RoID09PSA1KSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCdKV0Ugc3RydWN0dXJlIEpXVHMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAhPT0gMykge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdJbnZhbGlkIEpXVCcpO1xuICAgIH1cbiAgICBsZXQgaGVhZGVyO1xuICAgIHRyeSB7XG4gICAgICAgIGhlYWRlciA9IEpTT04ucGFyc2UoYnVmKGI2NHUocHJvdGVjdGVkSGVhZGVyKSkpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIEpXVCBIZWFkZXIgYm9keSBhcyBiYXNlNjR1cmwgZW5jb2RlZCBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoaGVhZGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdKV1QgSGVhZGVyIG11c3QgYmUgYSB0b3AgbGV2ZWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNoZWNrQWxnKGhlYWRlcik7XG4gICAgaWYgKGhlYWRlci5jcml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJjcml0XCIgaGVhZGVyIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSBiNjR1KGVuY29kZWRTaWduYXR1cmUpO1xuICAgIGlmIChnZXRLZXkgIT09IG5vU2lnbmF0dXJlQ2hlY2spIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgZ2V0S2V5KGhlYWRlcik7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYCR7cHJvdGVjdGVkSGVhZGVyfS4ke3BheWxvYWR9YDtcbiAgICAgICAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnZlcmlmeShrZXlUb1N1YnRsZShrZXkpLCBrZXksIHNpZ25hdHVyZSwgYnVmKGlucHV0KSk7XG4gICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ0pXVCBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjbGFpbXM7XG4gICAgdHJ5IHtcbiAgICAgICAgY2xhaW1zID0gSlNPTi5wYXJzZShidWYoYjY0dShwYXlsb2FkKSkpO1xuICAgIH1cbiAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnZmFpbGVkIHRvIHBhcnNlIEpXVCBQYXlsb2FkIGJvZHkgYXMgYmFzZTY0dXJsIGVuY29kZWQgSlNPTicsIHsgY2F1c2UgfSk7XG4gICAgfVxuICAgIGlmICghaXNKc29uT2JqZWN0KGNsYWltcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnSldUIFBheWxvYWQgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gZXBvY2hUaW1lKCkgKyBjbG9ja1NrZXc7XG4gICAgaWYgKGNsYWltcy5leHAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYWltcy5leHAgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImV4cFwiIChleHBpcmF0aW9uIHRpbWUpIGNsYWltIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhaW1zLmV4cCA8PSBub3cgLSBjbG9ja1RvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJleHBcIiAoZXhwaXJhdGlvbiB0aW1lKSBjbGFpbSB2YWx1ZSwgdGltZXN0YW1wIGlzIDw9IG5vdygpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsYWltcy5pYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYWltcy5pYXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImlhdFwiIChpc3N1ZWQgYXQpIGNsYWltIHR5cGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xhaW1zLmlzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhaW1zLmlzcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiaXNzXCIgKGlzc3VlcikgY2xhaW0gdHlwZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGFpbXMubmJmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMubmJmICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJuYmZcIiAobm90IGJlZm9yZSkgY2xhaW0gdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFpbXMubmJmID4gbm93ICsgY2xvY2tUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwibmJmXCIgKG5vdCBiZWZvcmUpIGNsYWltIHZhbHVlLCB0aW1lc3RhbXAgaXMgPiBub3coKScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGFpbXMuYXVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFpbXMuYXVkICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShjbGFpbXMuYXVkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhdWRcIiAoYXVkaWVuY2UpIGNsYWltIHR5cGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBoZWFkZXIsIGNsYWltcywgc2lnbmF0dXJlIH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVKd3RBdXRoUmVzcG9uc2UoYXMsIGNsaWVudCwgcGFyYW1ldGVycywgZXhwZWN0ZWRTdGF0ZSwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycy5zZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIGlmICghKHBhcmFtZXRlcnMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicGFyYW1ldGVyc1wiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMU2VhcmNoUGFyYW1zLCBvciBVUkwnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ3Jlc3BvbnNlJyk7XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInBhcmFtZXRlcnNcIiBkb2VzIG5vdCBjb250YWluIGEgSkFSTSByZXNwb25zZScpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFzLmp3a3NfdXJpICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFzLmp3a3NfdXJpXCIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCB7IGNsYWltcyB9ID0gYXdhaXQgdmFsaWRhdGVKd3QocmVzcG9uc2UsIGNoZWNrU2lnbmluZ0FsZ29yaXRobS5iaW5kKHVuZGVmaW5lZCwgY2xpZW50LmF1dGhvcml6YXRpb25fc2lnbmVkX3Jlc3BvbnNlX2FsZywgYXMuYXV0aG9yaXphdGlvbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkKSwgZ2V0UHVibGljU2lnS2V5RnJvbUlzc3Vlckp3a3NVcmkuYmluZCh1bmRlZmluZWQsIGFzLCBvcHRpb25zKSwgZ2V0Q2xvY2tTa2V3KGNsaWVudCksIGdldENsb2NrVG9sZXJhbmNlKGNsaWVudCkpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlUHJlc2VuY2UuYmluZCh1bmRlZmluZWQsIFsnYXVkJywgJ2V4cCcsICdpc3MnXSkpXG4gICAgICAgIC50aGVuKHZhbGlkYXRlSXNzdWVyLmJpbmQodW5kZWZpbmVkLCBhcy5pc3N1ZXIpKVxuICAgICAgICAudGhlbih2YWxpZGF0ZUF1ZGllbmNlLmJpbmQodW5kZWZpbmVkLCBjbGllbnQuY2xpZW50X2lkKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNsYWltcykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYga2V5ICE9PSAnYXVkJykge1xuICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVBdXRoUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzdWx0LCBleHBlY3RlZFN0YXRlKTtcbn1cbmZ1bmN0aW9uIGNoZWNrU2lnbmluZ0FsZ29yaXRobShjbGllbnQsIGlzc3VlciwgaGVhZGVyKSB7XG4gICAgaWYgKGNsaWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChoZWFkZXIuYWxnICE9PSBjbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3VuZXhwZWN0ZWQgSldUIFwiYWxnXCIgaGVhZGVyIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXNzdWVyKSkge1xuICAgICAgICBpZiAoIWlzc3Vlci5pbmNsdWRlcyhoZWFkZXIuYWxnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBKV1QgXCJhbGdcIiBoZWFkZXIgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaGVhZGVyLmFsZyAhPT0gJ1JTMjU2Jykge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCd1bmV4cGVjdGVkIEpXVCBcImFsZ1wiIGhlYWRlciBwYXJhbWV0ZXInKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgbmFtZSkge1xuICAgIGNvbnN0IHsgMDogdmFsdWUsIGxlbmd0aCB9ID0gcGFyYW1ldGVycy5nZXRBbGwobmFtZSk7XG4gICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRShgXCIke25hbWV9XCIgcGFyYW1ldGVyIG11c3QgYmUgcHJvdmlkZWQgb25seSBvbmNlYCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBjb25zdCBza2lwU3RhdGVDaGVjayA9IFN5bWJvbCgpO1xuZXhwb3J0IGNvbnN0IGV4cGVjdE5vU3RhdGUgPSBTeW1ib2woKTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUF1dGhSZXNwb25zZShhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBleHBlY3RlZFN0YXRlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmIChwYXJhbWV0ZXJzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzLnNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgaWYgKCEocGFyYW1ldGVycyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJwYXJhbWV0ZXJzXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkxTZWFyY2hQYXJhbXMsIG9yIFVSTCcpO1xuICAgIH1cbiAgICBpZiAoZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdyZXNwb25zZScpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicGFyYW1ldGVyc1wiIGNvbnRhaW5zIGEgSkFSTSByZXNwb25zZSwgdXNlIHZhbGlkYXRlSnd0QXV0aFJlc3BvbnNlKCkgaW5zdGVhZCBvZiB2YWxpZGF0ZUF1dGhSZXNwb25zZSgpJyk7XG4gICAgfVxuICAgIGNvbnN0IGlzcyA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnaXNzJyk7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ3N0YXRlJyk7XG4gICAgaWYgKCFpc3MgJiYgYXMuYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdyZXNwb25zZSBwYXJhbWV0ZXIgXCJpc3NcIiAoaXNzdWVyKSBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGlmIChpc3MgJiYgaXNzICE9PSBhcy5pc3N1ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBcImlzc1wiIChpc3N1ZXIpIHJlc3BvbnNlIHBhcmFtZXRlciB2YWx1ZScpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGV4cGVjdGVkU3RhdGUpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgZXhwZWN0Tm9TdGF0ZTpcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBcInN0YXRlXCIgcmVzcG9uc2UgcGFyYW1ldGVyIGVuY291bnRlcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBza2lwU3RhdGVDaGVjazpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhleHBlY3RlZFN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ1wiZXhwZWN0ZWRTdGF0ZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPUEUoJ3Jlc3BvbnNlIHBhcmFtZXRlciBcInN0YXRlXCIgbWlzc2luZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSBleHBlY3RlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9QRSgndW5leHBlY3RlZCBcInN0YXRlXCIgcmVzcG9uc2UgcGFyYW1ldGVyIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdlcnJvcicpO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBlcnJvcl9kZXNjcmlwdGlvbjogZ2V0VVJMU2VhcmNoUGFyYW1ldGVyKHBhcmFtZXRlcnMsICdlcnJvcl9kZXNjcmlwdGlvbicpLFxuICAgICAgICAgICAgZXJyb3JfdXJpOiBnZXRVUkxTZWFyY2hQYXJhbWV0ZXIocGFyYW1ldGVycywgJ2Vycm9yX3VyaScpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpZF90b2tlbiA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAnaWRfdG9rZW4nKTtcbiAgICBjb25zdCB0b2tlbiA9IGdldFVSTFNlYXJjaFBhcmFtZXRlcihwYXJhbWV0ZXJzLCAndG9rZW4nKTtcbiAgICBpZiAoaWRfdG9rZW4gIT09IHVuZGVmaW5lZCB8fCB0b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKCdpbXBsaWNpdCBhbmQgaHlicmlkIGZsb3dzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBicmFuZChuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpKTtcbn1cbmZ1bmN0aW9uIGFsZ1RvU3VidGxlKGFsZywgY3J2KSB7XG4gICAgc3dpdGNoIChhbGcpIHtcbiAgICAgICAgY2FzZSAnUFMyNTYnOlxuICAgICAgICBjYXNlICdQUzM4NCc6XG4gICAgICAgIGNhc2UgJ1BTNTEyJzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdSU0EtUFNTJywgaGFzaDogYFNIQS0ke2FsZy5zbGljZSgtMyl9YCB9O1xuICAgICAgICBjYXNlICdSUzI1Nic6XG4gICAgICAgIGNhc2UgJ1JTMzg0JzpcbiAgICAgICAgY2FzZSAnUlM1MTInOlxuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JywgaGFzaDogYFNIQS0ke2FsZy5zbGljZSgtMyl9YCB9O1xuICAgICAgICBjYXNlICdFUzI1Nic6XG4gICAgICAgIGNhc2UgJ0VTMzg0JzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdFQ0RTQScsIG5hbWVkQ3VydmU6IGBQLSR7YWxnLnNsaWNlKC0zKX1gIH07XG4gICAgICAgIGNhc2UgJ0VTNTEyJzpcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdFQ0RTQScsIG5hbWVkQ3VydmU6ICdQLTUyMScgfTtcbiAgICAgICAgY2FzZSAnRWREU0EnOiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNydikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0VkMjU1MTknOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0VkNDQ4JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNydjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcigpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGltcG9ydEp3ayhhbGcsIGp3aykge1xuICAgIGNvbnN0IHsgZXh0LCBrZXlfb3BzLCB1c2UsIC4uLmtleSB9ID0gandrO1xuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgnandrJywga2V5LCBhbGdUb1N1YnRsZShhbGcsIGp3ay5jcnYpLCB0cnVlLCBbJ3ZlcmlmeSddKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXZpY2VBdXRob3JpemF0aW9uUmVxdWVzdChhcywgY2xpZW50LCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICh0eXBlb2YgYXMuZGV2aWNlX2F1dGhvcml6YXRpb25fZW5kcG9pbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYXMuZGV2aWNlX2F1dGhvcml6YXRpb25fZW5kcG9pbnRcIiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYXMuZGV2aWNlX2F1dGhvcml6YXRpb25fZW5kcG9pbnQpO1xuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpO1xuICAgIGJvZHkuc2V0KCdjbGllbnRfaWQnLCBjbGllbnQuY2xpZW50X2lkKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0aW9ucz8uaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZWRSZXF1ZXN0KGFzLCBjbGllbnQsICdQT1NUJywgdXJsLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRGV2aWNlQXV0aG9yaXphdGlvblJlc3BvbnNlKGFzLCBjbGllbnQsIHJlc3BvbnNlKSB7XG4gICAgYXNzZXJ0QXMoYXMpO1xuICAgIGFzc2VydENsaWVudChjbGllbnQpO1xuICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wicmVzcG9uc2VcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFJlc3BvbnNlJyk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAoKGVyciA9IGF3YWl0IGhhbmRsZU9BdXRoQm9keUVycm9yKHJlc3BvbnNlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGlzIG5vdCBhIGNvbmZvcm0gRGV2aWNlIEF1dGhvcml6YXRpb24gRW5kcG9pbnQgcmVzcG9uc2UnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVhZGFibGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ2ZhaWxlZCB0byBwYXJzZSBcInJlc3BvbnNlXCIgYm9keSBhcyBKU09OJywgeyBjYXVzZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgbXVzdCBiZSBhIHRvcCBsZXZlbCBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLmRldmljZV9jb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgT1BFKCdcInJlc3BvbnNlXCIgYm9keSBcImRldmljZV9jb2RlXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZGF0ZVN0cmluZyhqc29uLnVzZXJfY29kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJ1c2VyX2NvZGVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGpzb24udmVyaWZpY2F0aW9uX3VyaSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9QRSgnXCJyZXNwb25zZVwiIGJvZHkgXCJ2ZXJpZmljYXRpb25fdXJpXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBqc29uLmV4cGlyZXNfaW4gIT09ICdudW1iZXInIHx8IGpzb24uZXhwaXJlc19pbiA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiZXhwaXJlc19pblwiIHByb3BlcnR5IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKGpzb24udmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICF2YWxpZGF0ZVN0cmluZyhqc29uLnZlcmlmaWNhdGlvbl91cmlfY29tcGxldGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwidmVyaWZpY2F0aW9uX3VyaV9jb21wbGV0ZVwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChqc29uLmludGVydmFsICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBqc29uLmludGVydmFsICE9PSAnbnVtYmVyJyB8fCBqc29uLmludGVydmFsIDw9IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBPUEUoJ1wicmVzcG9uc2VcIiBib2R5IFwiaW50ZXJ2YWxcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldmljZUNvZGVHcmFudFJlcXVlc3QoYXMsIGNsaWVudCwgZGV2aWNlQ29kZSwgb3B0aW9ucykge1xuICAgIGFzc2VydEFzKGFzKTtcbiAgICBhc3NlcnRDbGllbnQoY2xpZW50KTtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGRldmljZUNvZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGV2aWNlQ29kZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnM/LmFkZGl0aW9uYWxQYXJhbWV0ZXJzKTtcbiAgICBwYXJhbWV0ZXJzLnNldCgnZGV2aWNlX2NvZGUnLCBkZXZpY2VDb2RlKTtcbiAgICByZXR1cm4gdG9rZW5FbmRwb2ludFJlcXVlc3QoYXMsIGNsaWVudCwgJ3VybjppZXRmOnBhcmFtczpvYXV0aDpncmFudC10eXBlOmRldmljZV9jb2RlJywgcGFyYW1ldGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0RldmljZUNvZGVSZXNwb25zZShhcywgY2xpZW50LCByZXNwb25zZSkge1xuICAgIHJldHVybiBwcm9jZXNzR2VuZXJpY0FjY2Vzc1Rva2VuUmVzcG9uc2UoYXMsIGNsaWVudCwgcmVzcG9uc2UpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlS2V5UGFpcihhbGcsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXZhbGlkYXRlU3RyaW5nKGFsZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbGdcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCBhbGdvcml0aG0gPSBhbGdUb1N1YnRsZShhbGcsIGFsZyA9PT0gJ0VkRFNBJyA/IG9wdGlvbnM/LmNydiA/PyAnRWQyNTUxOScgOiB1bmRlZmluZWQpO1xuICAgIGlmIChhbGcuc3RhcnRzV2l0aCgnUFMnKSB8fCBhbGcuc3RhcnRzV2l0aCgnUlMnKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGFsZ29yaXRobSwge1xuICAgICAgICAgICAgbW9kdWx1c0xlbmd0aDogb3B0aW9ucz8ubW9kdWx1c0xlbmd0aCA/PyAyMDQ4LFxuICAgICAgICAgICAgcHVibGljRXhwb25lbnQ6IG5ldyBVaW50OEFycmF5KFsweDAxLCAweDAwLCAweDAxXSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKGNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBvcHRpb25zPy5leHRyYWN0YWJsZSA/PyBmYWxzZSwgWydzaWduJywgJ3ZlcmlmeSddKSk7XG59XG4iXSwibmFtZXMiOlsiVVNFUl9BR0VOVCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInN0YXJ0c1dpdGgiLCJOQU1FIiwiVkVSU0lPTiIsImNsb2NrU2tldyIsIlN5bWJvbCIsImNsb2NrVG9sZXJhbmNlIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiYnVmIiwiaW5wdXQiLCJlbmNvZGUiLCJkZWNvZGUiLCJDSFVOS19TSVpFIiwiZW5jb2RlQmFzZTY0VXJsIiwiQXJyYXlCdWZmZXIiLCJVaW50OEFycmF5IiwiYXJyIiwiaSIsImJ5dGVMZW5ndGgiLCJwdXNoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJzdWJhcnJheSIsImJ0b2EiLCJqb2luIiwicmVwbGFjZSIsImRlY29kZUJhc2U2NFVybCIsImJpbmFyeSIsImF0b2IiLCJieXRlcyIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJjYXVzZSIsIk9QRSIsImI2NHUiLCJMUlUiLCJjb25zdHJ1Y3RvciIsIm1heFNpemUiLCJjYWNoZSIsIk1hcCIsIl9jYWNoZSIsImdldCIsImtleSIsInYiLCJ1cGRhdGUiLCJ1bmRlZmluZWQiLCJoYXMiLCJzZXQiLCJ2YWx1ZSIsImRlbGV0ZSIsInNpemUiLCJVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwibmFtZSIsImNhcHR1cmVTdGFja1RyYWNlIiwiT3BlcmF0aW9uUHJvY2Vzc2luZ0Vycm9yIiwib3B0aW9ucyIsImRwb3BOb25jZXMiLCJpc0NyeXB0b0tleSIsIkNyeXB0b0tleSIsImlzUHJpdmF0ZUtleSIsInR5cGUiLCJpc1B1YmxpY0tleSIsIlNVUFBPUlRFRF9KV1NfQUxHUyIsInByb2Nlc3NEcG9wTm9uY2UiLCJyZXNwb25zZSIsInVybCIsIlVSTCIsImhlYWRlcnMiLCJvcmlnaW4iLCJub3JtYWxpemVUeXAiLCJ0b0xvd2VyQ2FzZSIsImlzSnNvbk9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInByZXBhcmVIZWFkZXJzIiwiSGVhZGVycyIsIlR5cGVFcnJvciIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwiZGlzY292ZXJ5UmVxdWVzdCIsImlzc3VlcklkZW50aWZpZXIiLCJwcm90b2NvbCIsImhyZWYiLCJhbGdvcml0aG0iLCJwYXRobmFtZSIsImZldGNoIiwibWV0aG9kIiwicmVkaXJlY3QiLCJ0aGVuIiwidmFsaWRhdGVTdHJpbmciLCJwcm9jZXNzRGlzY292ZXJ5UmVzcG9uc2UiLCJleHBlY3RlZElzc3VlcklkZW50aWZpZXIiLCJSZXNwb25zZSIsInN0YXR1cyIsImFzc2VydFJlYWRhYmxlUmVzcG9uc2UiLCJqc29uIiwiaXNzdWVyIiwicmFuZG9tQnl0ZXMiLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJnZW5lcmF0ZVJhbmRvbUNvZGVWZXJpZmllciIsImdlbmVyYXRlUmFuZG9tU3RhdGUiLCJnZW5lcmF0ZVJhbmRvbU5vbmNlIiwiY2FsY3VsYXRlUEtDRUNvZGVDaGFsbGVuZ2UiLCJjb2RlVmVyaWZpZXIiLCJzdWJ0bGUiLCJkaWdlc3QiLCJnZXRLZXlBbmRLaWQiLCJraWQiLCJmb3JtVXJsRW5jb2RlIiwidG9rZW4iLCJlbmNvZGVVUklDb21wb25lbnQiLCJjbGllbnRTZWNyZXRCYXNpYyIsImNsaWVudElkIiwiY2xpZW50U2VjcmV0IiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImNyZWRlbnRpYWxzIiwicHNBbGciLCJoYXNoIiwicnNBbGciLCJlc0FsZyIsIm5hbWVkQ3VydmUiLCJrZXlUb0p3cyIsImdldENsb2NrU2tldyIsImNsaWVudCIsIk51bWJlciIsImlzRmluaXRlIiwiZ2V0Q2xvY2tUb2xlcmFuY2UiLCJ0b2xlcmFuY2UiLCJNYXRoIiwic2lnbiIsImVwb2NoVGltZSIsImZsb29yIiwiRGF0ZSIsIm5vdyIsImNsaWVudEFzc2VydGlvbiIsImFzIiwianRpIiwiYXVkIiwidG9rZW5fZW5kcG9pbnQiLCJleHAiLCJpYXQiLCJuYmYiLCJpc3MiLCJjbGllbnRfaWQiLCJzdWIiLCJwcml2YXRlS2V5Snd0Iiwiand0IiwiYWxnIiwiYXNzZXJ0QXMiLCJhc3NlcnRDbGllbnQiLCJhc3NlcnRDbGllbnRTZWNyZXQiLCJhc3NlcnROb0NsaWVudFByaXZhdGVLZXkiLCJjbGllbnRBdXRoTWV0aG9kIiwiY2xpZW50UHJpdmF0ZUtleSIsImFzc2VydE5vQ2xpZW50U2VjcmV0IiwiY2xpZW50QXV0aGVudGljYXRpb24iLCJib2R5IiwidG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QiLCJjbGllbnRfc2VjcmV0IiwiaGVhZGVyIiwiY2xhaW1zU2V0IiwidXNhZ2VzIiwiaW5jbHVkZXMiLCJKU09OIiwic3RyaW5naWZ5Iiwic2lnbmF0dXJlIiwia2V5VG9TdWJ0bGUiLCJpc3N1ZVJlcXVlc3RPYmplY3QiLCJwYXJhbWV0ZXJzIiwicHJpdmF0ZUtleSIsIlVSTFNlYXJjaFBhcmFtcyIsImNsYWltcyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsInJlc291cmNlIiwiZ2V0QWxsIiwicGFyc2UiLCJ0eXAiLCJkcG9wUHJvb2ZKd3QiLCJodG0iLCJhY2Nlc3NUb2tlbiIsInB1YmxpY0tleSIsIm5vbmNlIiwiZXh0cmFjdGFibGUiLCJwcm9vZiIsImp3ayIsInB1YmxpY0p3ayIsImh0dSIsImF0aCIsImp3a0NhY2hlIiwiV2Vha01hcCIsImt0eSIsImUiLCJuIiwieCIsInkiLCJjcnYiLCJleHBvcnRLZXkiLCJwdXNoZWRBdXRob3JpemF0aW9uUmVxdWVzdCIsInB1c2hlZF9hdXRob3JpemF0aW9uX3JlcXVlc3RfZW5kcG9pbnQiLCJEUG9QIiwiYXV0aGVudGljYXRlZFJlcXVlc3QiLCJpc09BdXRoMkVycm9yIiwiZXJyb3IiLCJ1bnF1b3RlIiwic2xpY2UiLCJTUExJVF9SRUdFWFAiLCJTQ0hFTUVTX1JFR0VYUCIsInd3d0F1dGgiLCJzY2hlbWUiLCJwYXJhbXMiLCJzcGxpdCIsImlkeCIsInBhcnNlV3d3QXV0aGVudGljYXRlQ2hhbGxlbmdlcyIsInJlc3VsdCIsImluZGV4IiwibWF0Y2hBbGwiLCJjaGFsbGVuZ2VzIiwibWFwIiwiaW5kZXhPZiIsIm90aGVycyIsIm5leHQiLCJwcm9jZXNzUHVzaGVkQXV0aG9yaXphdGlvblJlc3BvbnNlIiwiZXJyIiwiaGFuZGxlT0F1dGhCb2R5RXJyb3IiLCJyZXF1ZXN0X3VyaSIsImV4cGlyZXNfaW4iLCJwcm90ZWN0ZWRSZXNvdXJjZVJlcXVlc3QiLCJ1c2VySW5mb1JlcXVlc3QiLCJ1c2VyaW5mb19lbmRwb2ludCIsInVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGciLCJhcHBlbmQiLCJqd2tzQ2FjaGUiLCJnZXRQdWJsaWNTaWdLZXlGcm9tSXNzdWVySndrc1VyaSIsImNoZWNrU3VwcG9ydGVkSndzQWxnIiwiandrcyIsImFnZSIsImp3a3NSZXF1ZXN0IiwicHJvY2Vzc0p3a3NSZXNwb25zZSIsImNhbmRpZGF0ZXMiLCJrZXlzIiwiZmlsdGVyIiwidXNlIiwia2V5X29wcyIsImltcG9ydEp3ayIsInNraXBTdWJqZWN0Q2hlY2siLCJnZXRDb250ZW50VHlwZSIsInByb2Nlc3NVc2VySW5mb1Jlc3BvbnNlIiwiZXhwZWN0ZWRTdWJqZWN0IiwidmFsaWRhdGVKd3QiLCJ0ZXh0IiwiY2hlY2tTaWduaW5nQWxnb3JpdGhtIiwiYmluZCIsInVzZXJpbmZvX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJub1NpZ25hdHVyZUNoZWNrIiwidmFsaWRhdGVPcHRpb25hbEF1ZGllbmNlIiwidmFsaWRhdGVPcHRpb25hbElzc3VlciIsInRva2VuRW5kcG9pbnRSZXF1ZXN0IiwiZ3JhbnRUeXBlIiwicmVmcmVzaFRva2VuR3JhbnRSZXF1ZXN0IiwicmVmcmVzaFRva2VuIiwiYWRkaXRpb25hbFBhcmFtZXRlcnMiLCJpZFRva2VuQ2xhaW1zIiwiZ2V0VmFsaWRhdGVkSWRUb2tlbkNsYWltcyIsInJlZiIsImlkX3Rva2VuIiwicHJvY2Vzc0dlbmVyaWNBY2Nlc3NUb2tlblJlc3BvbnNlIiwiaWdub3JlSWRUb2tlbiIsImlnbm9yZVJlZnJlc2hUb2tlbiIsImFjY2Vzc190b2tlbiIsInRva2VuX3R5cGUiLCJyZWZyZXNoX3Rva2VuIiwic2NvcGUiLCJpZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnIiwiaWRfdG9rZW5fc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCIsInZhbGlkYXRlUHJlc2VuY2UiLCJ2YWxpZGF0ZUlzc3VlciIsInZhbGlkYXRlQXVkaWVuY2UiLCJhenAiLCJyZXF1aXJlX2F1dGhfdGltZSIsImF1dGhfdGltZSIsInByb2Nlc3NSZWZyZXNoVG9rZW5SZXNwb25zZSIsImV4cGVjdGVkIiwiYnJhbmRlZCIsIldlYWtTZXQiLCJicmFuZCIsInNlYXJjaFBhcmFtcyIsImFkZCIsImF1dGhvcml6YXRpb25Db2RlR3JhbnRSZXF1ZXN0IiwiY2FsbGJhY2tQYXJhbWV0ZXJzIiwicmVkaXJlY3RVcmkiLCJjb2RlIiwiZ2V0VVJMU2VhcmNoUGFyYW1ldGVyIiwiY2xhaW1OYW1lcyIsInJlcXVpcmVkIiwiY2xhaW0iLCJleHBlY3ROb05vbmNlIiwic2tpcEF1dGhUaW1lQ2hlY2siLCJwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVPcGVuSURSZXNwb25zZSIsImV4cGVjdGVkTm9uY2UiLCJtYXhBZ2UiLCJkZWZhdWx0X21heF9hZ2UiLCJwcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVPQXV0aDJSZXNwb25zZSIsImNoZWNrSnd0VHlwZSIsImNsaWVudENyZWRlbnRpYWxzR3JhbnRSZXF1ZXN0IiwicHJvY2Vzc0NsaWVudENyZWRlbnRpYWxzUmVzcG9uc2UiLCJyZXZvY2F0aW9uUmVxdWVzdCIsInJldm9jYXRpb25fZW5kcG9pbnQiLCJwcm9jZXNzUmV2b2NhdGlvblJlc3BvbnNlIiwiYm9keVVzZWQiLCJpbnRyb3NwZWN0aW9uUmVxdWVzdCIsImludHJvc3BlY3Rpb25fZW5kcG9pbnQiLCJyZXF1ZXN0Snd0UmVzcG9uc2UiLCJpbnRyb3NwZWN0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGciLCJwcm9jZXNzSW50cm9zcGVjdGlvblJlc3BvbnNlIiwiaW50cm9zcGVjdGlvbl9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIiwidG9rZW5faW50cm9zcGVjdGlvbiIsImFjdGl2ZSIsImp3a3NfdXJpIiwicHJvdG90eXBlIiwiZXZlcnkiLCJjYWxsIiwiZXJyb3JfZGVzY3JpcHRpb24iLCJlcnJvcl91cmkiLCJhbGdzIiwiY2hlY2tSc2FLZXlBbGdvcml0aG0iLCJtb2R1bHVzTGVuZ3RoIiwiZWNkc2FIYXNoTmFtZSIsInNhbHRMZW5ndGgiLCJwYXJzZUludCIsImp3cyIsImNoZWNrQWxnIiwiZ2V0S2V5IiwicHJvdGVjdGVkSGVhZGVyIiwicGF5bG9hZCIsImVuY29kZWRTaWduYXR1cmUiLCJjcml0IiwidmVyaWZpZWQiLCJ2ZXJpZnkiLCJ2YWxpZGF0ZUp3dEF1dGhSZXNwb25zZSIsImV4cGVjdGVkU3RhdGUiLCJhdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGciLCJhdXRob3JpemF0aW9uX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQiLCJ2YWxpZGF0ZUF1dGhSZXNwb25zZSIsInNraXBTdGF0ZUNoZWNrIiwiZXhwZWN0Tm9TdGF0ZSIsInN0YXRlIiwiYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZCIsImFsZ1RvU3VidGxlIiwiZXh0IiwiaW1wb3J0S2V5IiwiZGV2aWNlQXV0aG9yaXphdGlvblJlcXVlc3QiLCJkZXZpY2VfYXV0aG9yaXphdGlvbl9lbmRwb2ludCIsInByb2Nlc3NEZXZpY2VBdXRob3JpemF0aW9uUmVzcG9uc2UiLCJkZXZpY2VfY29kZSIsInVzZXJfY29kZSIsInZlcmlmaWNhdGlvbl91cmkiLCJ2ZXJpZmljYXRpb25fdXJpX2NvbXBsZXRlIiwiaW50ZXJ2YWwiLCJkZXZpY2VDb2RlR3JhbnRSZXF1ZXN0IiwiZGV2aWNlQ29kZSIsInByb2Nlc3NEZXZpY2VDb2RlUmVzcG9uc2UiLCJnZW5lcmF0ZUtleVBhaXIiLCJhc3NpZ24iLCJwdWJsaWNFeHBvbmVudCIsImdlbmVyYXRlS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/oauth4webapi/build/index.js\n");

/***/ })

};
;